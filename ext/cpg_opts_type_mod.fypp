#:mute
#:set config_file = os.path.dirname(_THIS_FILE_) + '/field_config.yaml'
#:set config = field_config.VariableConfiguration(config_file)
#:set gfl = config.groups['GFL'] 
#:set surf_config_file = os.path.dirname(_THIS_FILE_) + '/surface_fields_config.yaml'
#:set surf_config = field_config.VariableConfiguration(surf_config_file)
#:set prognostic = [field_config.VariableGroup(**group) for group in surf_config.schema['prognostic']]
#:set diagnostic = [field_config.VariableGroup(**group) for group in surf_config.schema['diagnostic']]
#:set variable_groups = prognostic + diagnostic

#:endmute
MODULE CPG_OPTS_TYPE_MOD

USE PARKIND1, ONLY : JPIM, JPRB
USE GEOMETRY_MOD, ONLY : GEOMETRY
USE YOMCLI, ONLY : TCLI
USE SURFACE_FIELDS_MIX , ONLY : TYPE_SURF_GEN

IMPLICIT NONE

TYPE CPG_DIM_VAR_TYPE
  INTEGER(KIND=JPIM) :: ILEVT1I
  INTEGER(KIND=JPIM) :: ILEVT1F
END TYPE

#:def cpg_dim_var_decl (var)
  TYPE (CPG_DIM_VAR_TYPE) :: ${var}$
#:enddef

TYPE CPG_DIMS_VARS_TYPE
$:cpg_dim_var_decl ("U")
$:cpg_dim_var_decl ("V")
$:cpg_dim_var_decl ("T")
$:cpg_dim_var_decl ("SVD")
#:for v in gfl.variables
  #:if v.array
  #:elif v.dim == 3
$:cpg_dim_var_decl (v.name)
  #:endif
#:endfor
CONTAINS 
  PROCEDURE :: INIT => CPG_DIMS_VARS_TYPE_INIT
END TYPE CPG_DIMS_VARS_TYPE

TYPE CPG_DIMS_SURF_TYPE
#:for group in prognostic
  TYPE (TYPE_SURF_GEN) :: YSP_${group.short}$D
#:endfor
#:for group in diagnostic
  TYPE (TYPE_SURF_GEN) :: YSD_${group.short}$D
#:endfor
CONTAINS
  PROCEDURE :: INIT => CPG_DIMS_SURF_TYPE_INIT
END TYPE

TYPE CPG_BNDS_TYPE
  INTEGER(KIND=JPIM) :: KIDIA 
  INTEGER(KIND=JPIM) :: KFDIA 
  INTEGER(KIND=JPIM) :: KFDIE 
  INTEGER(KIND=JPIM) :: KIDIE
  INTEGER(KIND=JPIM) :: KBL 
  INTEGER(KIND=JPIM) :: KSTGLO 

  INTEGER(KIND=JPIM) :: KLON 
  INTEGER(KIND=JPIM) :: KGPTOT 
  INTEGER(KIND=JPIM) :: KGPCOMP 

CONTAINS
  PROCEDURE :: INIT => CPG_BNDS_TYPE_INIT
  PROCEDURE :: UPDATE => CPG_BNDS_TYPE_UPDATE
END TYPE CPG_BNDS_TYPE

#:for group in prognostic
  #:for v in group.variables
    #:if v.array
    #:else
TYPE CPG_SURF_${group.short}$_${v.name}$P_OPTS_TYPE
  LOGICAL :: LSET = .FALSE.
END TYPE
    #:endif

  #:endfor
TYPE CPG_SURF_${group.short}$P_OPTS_TYPE
  #:for v in group.variables
    #:if v.array
    #:else
  TYPE (CPG_SURF_${group.short}$_${v.name}$P_OPTS_TYPE) :: Y${v.name}$
    #:endif
  #:endfor
END TYPE

#:endfor
#:for group in diagnostic
  #:for v in group.variables
    #:if v.array
    #:else
TYPE CPG_SURF_${group.short}$_${v.name}$D_OPTS_TYPE
  LOGICAL :: LSET = .FALSE.
END TYPE
    #:endif

  #:endfor
TYPE CPG_SURF_${group.short}$D_OPTS_TYPE
  #:for v in group.variables
    #:if v.array
    #:else
  TYPE (CPG_SURF_${group.short}$_${v.name}$D_OPTS_TYPE) :: Y${v.name}$ 
    #:endif
  #:endfor
END TYPE

#:endfor

TYPE CPG_OPTS_SURF_TYPE

#:for group in prognostic
  TYPE (CPG_SURF_${group.short}$P_OPTS_TYPE) :: YSP_${group.short}$
#:endfor
#:for group in diagnostic
  TYPE (CPG_SURF_${group.short}$D_OPTS_TYPE) :: YSD_${group.short}$
#:endfor
CONTAINS
  PROCEDURE :: INIT => CPG_OPTS_SURF_TYPE_INIT
END TYPE

TYPE CPG_OPTS_TYPE

  INTEGER(KIND=JPIM) :: KLON 
  INTEGER(KIND=JPIM) :: KFLEVG 
  INTEGER(KIND=JPIM) :: KGPTOT 
  INTEGER(KIND=JPIM) :: KGPBLKS
  INTEGER(KIND=JPIM) :: KGPCOMP 
  INTEGER(KIND=JPIM) :: KGL1
  INTEGER(KIND=JPIM) :: KGL2
  INTEGER(KIND=JPIM) :: NSTEP
  INTEGER(KIND=JPIM) :: KTDIA
  INTEGER(KIND=JPIM) :: KVCLIS
  INTEGER(KIND=JPIM) :: NDTPREC
  INTEGER(KIND=JPIM) :: NDTPREC2
  INTEGER(KIND=JPIM) :: NDTPRECCUR
  INTEGER(KIND=JPIM) :: NDTPRECCUR2
  INTEGER(KIND=JPIM) :: KTSSG
  INTEGER(KIND=JPIM) :: KGRADIENTS
  INTEGER(KIND=JPIM) :: KMAXDRAFT
  INTEGER(KIND=JPIM) :: KSW
  
  TYPE (CPG_OPTS_SURF_TYPE) :: YRSURF_OPTS
  TYPE (CPG_DIMS_SURF_TYPE) :: YRSURF_DIMS
  TYPE (CPG_DIMS_VARS_TYPE) :: YRVARS_DIMS

  LOGICAL :: LCONFX, L_DFISTEP, LFSTEP, LDIAB, LSLPHY, LUSEPB1
  REAL(KIND=JPRB) :: ZDT, ZDTPHY, ZTE, ZBETADT

  TYPE (TCLI) :: YRCLI
  
  INTEGER (KIND=JPIM) :: NSSSSS
  INTEGER (KIND=JPIM) :: NFNUDG
  INTEGER (KIND=JPIM) :: NINDAT
  LOGICAL :: LAROME 
  LOGICAL :: LCALLSFX 
  LOGICAL :: LCORWAT
  LOGICAL :: LECMWF
  LOGICAL :: LINITER
  LOGICAL :: LELAM
  LOGICAL :: LFLASH
  LOGICAL :: LNUDG
  LOGICAL :: LRPLANE
  LOGICAL :: LSFORC
  LOGICAL :: LSFORCS  
  LOGICAL :: LSOMEGA_FRC
  LOGICAL :: LSPS_FRC
  LOGICAL :: LSW_FRC
  LOGICAL :: LXCLP
  LOGICAL :: LXTGST
  LOGICAL :: LXXGST
  REAL (KIND=JPRB) :: RPLDARE 
  REAL (KIND=JPRB) :: RPLRG
  REAL (KIND=JPRB) :: TOPPRES
  REAL (KIND=JPRB) :: RPSTRA
  REAL (KIND=JPRB) :: RPTROP
  REAL (KIND=JPRB) :: RTSUR
  REAL (KIND=JPRB), ALLOCATABLE :: XPNUDG (:)


CONTAINS
  PROCEDURE :: INIT => CPG_OPTS_TYPE_INIT
END TYPE CPG_OPTS_TYPE

CONTAINS

  SUBROUTINE CPG_OPTS_TYPE_INIT (SELF, YDGEOMETRY, YDMODEL, YDFIELDS, CDCONF, LD_DFISTEP)
    


    USE FIELDS_MOD, ONLY : FIELDS
    USE TYPE_MODEL, ONLY : MODEL
    USE YOMCT0,     ONLY : LAROME, LCORWAT, LELAM, LSFORCS, LCALLSFX, LSFORC, LRPLANE, LECMWF
    USE YOMCT3,     ONLY : NSTEP
    USE YOMSTA,     ONLY : RPSTRA, RPTROP, RTSUR
    USE YOMVERT,    ONLY : TOPPRES
    USE YOMDYNCORE, ONLY : RPLDARE, RPLRG
    USE YOMLSFORC,  ONLY : LSPS_FRC, LSW_FRC, LSOMEGA_FRC
    USE YOMLUN,     ONLY : NULOUT
    USE YOMNUD,     ONLY : NFNUDG, LNUDG
    USE YOMRIP0,    ONLY : NINDAT
    USE YOMSNU,     ONLY : XPNUDG
    USE YOMRIP0,    ONLY : NSSSSS
    USE YOMINI,     ONLY : LINITER
    USE YOMCLI,     ONLY : YRCLI

    CLASS(CPG_OPTS_TYPE) :: SELF
    TYPE(MODEL)   , INTENT(IN) :: YDMODEL
    TYPE(GEOMETRY), INTENT(IN) :: YDGEOMETRY
    TYPE(FIELDS),   INTENT(IN) :: YDFIELDS
    CHARACTER*1,    INTENT(IN) :: CDCONF
    LOGICAL,        INTENT(IN) :: LD_DFISTEP

#include "abor1.intfb.h"

    REAL(KIND=JPRB)    :: ZSTATI
    LOGICAL :: LLCT, LLCTC

    SELF%LFLASH  = YDFIELDS%YRCFU%LFLASH
    SELF%LXCLP   = YDFIELDS%YRXFU%LXCLP
    SELF%LXTGST  = YDFIELDS%YRXFU%LXTGST
    SELF%LXXGST  = YDFIELDS%YRXFU%LXXGST

    SELF%LAROME                = LAROME 
    SELF%LCALLSFX              = LCALLSFX 
    SELF%LINITER               = LINITER
    SELF%LCORWAT               = LCORWAT
    SELF%LECMWF                = LECMWF
    SELF%LELAM                 = LELAM

    SELF%LNUDG                 = LNUDG
    SELF%LRPLANE               = LRPLANE
    SELF%LSFORC                = LSFORC
    SELF%LSFORCS               = LSFORCS 
    SELF%LSFORCS               = LSFORCS  

    SELF%LSPS_FRC              = LSPS_FRC
    SELF%LSW_FRC               = LSW_FRC
    SELF%NSSSSS                = NSSSSS
    SELF%NFNUDG                = NFNUDG
    SELF%NINDAT                = NINDAT
    SELF%RPLDARE               = RPLDARE 
    SELF%RPLRG                 = RPLRG
    SELF%TOPPRES               = TOPPRES
    IF (ALLOCATED (XPNUDG)) THEN
    SELF%XPNUDG                = XPNUDG
    ENDIF
    SELF%RPSTRA                = RPSTRA
    SELF%RPTROP                = RPTROP
    SELF%RTSUR                 = RTSUR 

    SELF%YRCLI = YRCLI

    SELF%L_DFISTEP = LD_DFISTEP

    LLCT =YDMODEL%YRML_DYN%YRDYNA%LPC_FULL.AND.(YDMODEL%YRML_DYN%YRDYN%NCURRENT_ITER > 0)
    LLCTC=YDMODEL%YRML_DYN%YRDYNA%LPC_CHEAP.AND.(YDMODEL%YRML_DYN%YRDYN%NCURRENT_ITER > 0)
    IF(NSTEP > 0) THEN
      SELF%LFSTEP=.FALSE.
    ELSE
      SELF%LFSTEP=.TRUE.
    ENDIF
    
    ! Physics is called in CPG
    SELF%LDIAB= (YDMODEL%YRML_PHY_MF%YRPHY%LMPHYS.OR.YDMODEL%YRML_PHY_EC%YREPHY%LEPHYS) .AND. .NOT. YDMODEL%YRML_PHY_EC%YREPHY%LAGPHY .AND. (YDMODEL%YRML_DYN%YRDYN%NCURRENT_ITER == 0)
    SELF%LSLPHY = YDMODEL%YRML_PHY_EC%YREPHY%LSLPHY.AND.YDMODEL%YRML_DYN%YRDYNA%LSLAG.AND.(.NOT.LLCTC)
    ! Initial fluxes
    IF (CDCONF == 'X') THEN
      SELF%LFSTEP=.TRUE.
    ENDIF
    
    IF (YDMODEL%YRML_DYN%YRDYNA%LSLAG .AND. ((YDMODEL%YRML_DYN%YRDYN%NCURRENT_ITER == 0).OR.(LLCT.AND.(.NOT.LLCTC))) ) THEN 
      SELF%LUSEPB1=.TRUE.
    ELSE
      SELF%LUSEPB1=.FALSE.
    ENDIF

    IF (CDCONF == 'A'.OR.CDCONF == 'B') THEN
      ! usual time-step
      SELF%ZDT=YDMODEL%YRML_GCONF%YRRIP%TDT
      SELF%ZDTPHY=YDMODEL%YRML_GCONF%YRRIP%TDT
      SELF%ZTE=1.0_JPRB
      SELF%ZBETADT=YDMODEL%YRML_DYN%YRDYN%BETADT
      SELF%LCONFX=.FALSE.
    ELSEIF (CDCONF == 'X') THEN
      ! usual time-step for diagnostics but no SI scheme.
      SELF%ZDT=YDMODEL%YRML_GCONF%YRRIP%TDT
      SELF%ZDTPHY=YDMODEL%YRML_GCONF%YRRIP%TDT
      SELF%ZTE=1.0_JPRB
      SELF%ZBETADT=0.0_JPRB
      SELF%LCONFX=.TRUE.
    ELSE
      WRITE(NULOUT,*)'*********ERROR ON CDCONF'
      CALL ABOR1('CPG_DRV: ABOR1 CALLED')
    ENDIF

    SELF%KLON         =  YDGEOMETRY%YRDIM%NPROMA
    SELF%KFLEVG       =  YDGEOMETRY%YRDIMV%NFLEVG
    SELF%KGPTOT       =  YDGEOMETRY%YRGEM%NGPTOT
    SELF%KGPBLKS      =  YDGEOMETRY%YRDIM%NGPBLKS
    SELF%KGPCOMP      =  YDGEOMETRY%YRGEM%NGPTOT_CAP
    SELF%NSTEP        =  NSTEP
    SELF%KGL1         =  1
    SELF%KGL2         =  YDGEOMETRY%YRDIM%NDGENL
    SELF%KTDIA        =  1
    SELF%KVCLIS       =  YDMODEL%YRML_PHY_G%YRDPHY%NVCLIS
    SELF%NDTPREC      =  YDMODEL%YRML_PHY_MF%YRPHY%YRDPRECIPS%NDTPREC
    SELF%NDTPREC2     =  YDMODEL%YRML_PHY_MF%YRPHY%YRDPRECIPS%NDTPREC2
    SELF%KTSSG        =  YDMODEL%YRML_PHY_G%YRDPHY%NTSSG
    SELF%KGRADIENTS   =  YDMODEL%YRML_PHY_MF%YRARPHY%NGRADIENTS

    IF (YDMODEL%YRML_PHY_MF%YRARPHY%LMFSHAL .AND. YDMODEL%YRML_PHY_MF%YRPARAR%PHYEX%PARAM_MFSHALLN%CMF_UPDRAFT=='DUAL') THEN
      SELF%KMAXDRAFT=3
    ELSE
      SELF%KMAXDRAFT=0
    ENDIF

    IF (YDMODEL%YRML_PHY_MF%YRPHY%LRAY) THEN
      SELF%KSW = 1
    ELSE
      SELF%KSW = YDMODEL%YRML_PHY_RAD%YRERAD%NSW
    ENDIF

    IF (SELF%LCONFX) THEN 
      ZSTATI=REAL(YDMODEL%YRML_GCONF%YRRIP%RSTATI,JPRB)-0.01_JPRB/2._JPRB
    ELSE
      ZSTATI=REAL(YDMODEL%YRML_GCONF%YRRIP%RSTATI,JPRB)
    ENDIF

    IF (YDMODEL%YRML_PHY_MF%YRPHY%LDPRECIPS) THEN
      SELF%NDTPRECCUR  = INT(MOD(ZSTATI/YDMODEL%YRML_GCONF%YRRIP%TSTEP,REAL(YDMODEL%YRML_PHY_MF%YRPHY%YRDPRECIPS%NDTPREC))) +1_JPIM
    ENDIF
    IF (YDMODEL%YRML_PHY_MF%YRPHY%LDPRECIPS2) THEN
      SELF%NDTPRECCUR2 = INT(MOD(ZSTATI/YDMODEL%YRML_GCONF%YRRIP%TSTEP,REAL(YDMODEL%YRML_PHY_MF%YRPHY%YRDPRECIPS%NDTPREC2)))+1_JPIM
    ENDIF

    CALL SELF%YRSURF_OPTS%INIT (YDGEOMETRY, YDMODEL, YDFIELDS)
    CALL SELF%YRSURF_DIMS%INIT (YDGEOMETRY, YDMODEL, YDFIELDS)
    CALL SELF%YRVARS_DIMS%INIT (YDGEOMETRY, YDMODEL, YDFIELDS%VARIABLES)

  END SUBROUTINE CPG_OPTS_TYPE_INIT

  SUBROUTINE CPG_OPTS_SURF_TYPE_INIT (SELF, YDGEOMETRY, YDMODEL, YDFIELDS)
    USE TYPE_MODEL, ONLY : MODEL
    USE FIELDS_MOD, ONLY : FIELDS
    CLASS(CPG_OPTS_SURF_TYPE) :: SELF
    TYPE(MODEL)   , INTENT(IN) :: YDMODEL
    TYPE(GEOMETRY), INTENT(IN) :: YDGEOMETRY
    TYPE(FIELDS),   INTENT(IN) :: YDFIELDS

#:for group in prognostic
  #:for v in group.variables
    #:if v.array
    #:else
    IF (ASSOCIATED (YDFIELDS%YRSURF%YSP_${group.short}$%Y${v.name}$)) &
  & SELF%YSP_${group.short}$%Y${v.name}$%LSET = YDFIELDS%YRSURF%YSP_${group.short}$%Y${v.name}$%LSET
    #:endif
  #:endfor
#:endfor
#:for group in diagnostic
  #:for v in group.variables
    #:if v.array
    #:else
    IF (ASSOCIATED (YDFIELDS%YRSURF%YSD_${group.short}$%Y${v.name}$)) &
  & SELF%YSD_${group.short}$%Y${v.name}$%LSET = YDFIELDS%YRSURF%YSD_${group.short}$%Y${v.name}$%LSET
    #:endif
  #:endfor
#:endfor

  END SUBROUTINE CPG_OPTS_SURF_TYPE_INIT

  SUBROUTINE CPG_BNDS_TYPE_INIT(SELF, YDCPG_OPTS)
    CLASS(CPG_BNDS_TYPE) :: SELF
    TYPE(CPG_OPTS_TYPE), INTENT(IN) :: YDCPG_OPTS

    SELF%KBL          =  1
    SELF%KLON         =  YDCPG_OPTS%KLON
    SELF%KIDIA        =  1
    SELF%KIDIE        =  1
    SELF%KFDIA        =  YDCPG_OPTS%KLON
    SELF%KFDIE        =  YDCPG_OPTS%KLON
    SELF%KGPTOT       =  YDCPG_OPTS%KGPTOT
    SELF%KGPCOMP      =  YDCPG_OPTS%KGPCOMP

  END SUBROUTINE CPG_BNDS_TYPE_INIT

  SUBROUTINE CPG_DIMS_SURF_TYPE_INIT (SELF, YDGEOMETRY, YDMODEL, YDFIELDS)
    USE TYPE_MODEL, ONLY : MODEL
    USE FIELDS_MOD, ONLY : FIELDS
    CLASS(CPG_DIMS_SURF_TYPE) :: SELF
    TYPE(MODEL)   , INTENT(IN) :: YDMODEL
    TYPE(GEOMETRY), INTENT(IN) :: YDGEOMETRY
    TYPE(FIELDS),   INTENT(IN) :: YDFIELDS

#:for group in prognostic
    SELF%YSP_${group.short}$D = YDFIELDS%YRSURF%YSP_${group.short}$D
#:endfor
#:for group in diagnostic
    SELF%YSD_${group.short}$D = YDFIELDS%YRSURF%YSD_${group.short}$D
#:endfor

  END SUBROUTINE CPG_DIMS_SURF_TYPE_INIT

  SUBROUTINE CPG_BNDS_TYPE_UPDATE(SELF, IBL)
    CLASS(CPG_BNDS_TYPE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: IBL

    SELF%KBL    = IBL
    SELF%KSTGLO = 1 + (IBL - 1) * SELF%KLON
    SELF%KFDIA  = MIN (SELF%KLON, SELF%KGPCOMP - SELF%KSTGLO + 1)
    SELF%KFDIE  = MIN (SELF%KLON, SELF%KGPTOT  - SELF%KSTGLO + 1)

  END SUBROUTINE CPG_BNDS_TYPE_UPDATE

  SUBROUTINE CPG_DIMS_VARS_TYPE_INIT (SELF, YDGEOMETRY, YDMODEL, YDVARS)
    USE TYPE_MODEL, ONLY : MODEL
    USE FIELD_VARIABLES_MOD, ONLY: FIELD_VARIABLES
    CLASS(CPG_DIMS_VARS_TYPE) :: SELF
    TYPE(MODEL)   , INTENT(IN) :: YDMODEL
    TYPE(GEOMETRY), INTENT(IN) :: YDGEOMETRY
    TYPE(FIELD_VARIABLES),   INTENT(IN) :: YDVARS

    IF (YDMODEL%YRML_DYN%YRDYNA%LSLAG) THEN
    
      SELF%U   = CPG_DIM_VAR_TYPE (0, YDGEOMETRY%YRDIMV%NFLEVG+1)
      SELF%V   = CPG_DIM_VAR_TYPE (0, YDGEOMETRY%YRDIMV%NFLEVG+1)
      SELF%T   = CPG_DIM_VAR_TYPE (0, YDGEOMETRY%YRDIMV%NFLEVG+1)
      SELF%SVD = CPG_DIM_VAR_TYPE (0, YDGEOMETRY%YRDIMV%NFLEVG+1)
      
#:for v in gfl.variables
  #:if v.array
  #:elif v.dim == 3
      IF (YDVARS%${v.name}$%LADV) THEN
        SELF%${v.name}$ = CPG_DIM_VAR_TYPE (0, YDGEOMETRY%YRDIMV%NFLEVG+1)
      ELSE
        SELF%${v.name}$ = CPG_DIM_VAR_TYPE (1, YDGEOMETRY%YRDIMV%NFLEVG)
      ENDIF
  #:endif
#:endfor

    ELSE

      SELF%U   = CPG_DIM_VAR_TYPE (1, YDGEOMETRY%YRDIMV%NFLEVG)
      SELF%V   = CPG_DIM_VAR_TYPE (1, YDGEOMETRY%YRDIMV%NFLEVG)
      SELF%T   = CPG_DIM_VAR_TYPE (1, YDGEOMETRY%YRDIMV%NFLEVG)
      SELF%SVD = CPG_DIM_VAR_TYPE (1, YDGEOMETRY%YRDIMV%NFLEVG)
      
#:for v in gfl.variables
  #:if v.array
  #:elif v.dim == 3
      SELF%${v.name}$ = CPG_DIM_VAR_TYPE (1, YDGEOMETRY%YRDIMV%NFLEVG)
  #:endif
#:endfor

    ENDIF

  END SUBROUTINE 

END MODULE CPG_OPTS_TYPE_MOD
