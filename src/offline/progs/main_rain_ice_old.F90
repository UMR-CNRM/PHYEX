PROGRAM MAIN_RAIN_ICE_OLD

USE XRD_GETOPTIONS,  ONLY: INITOPTIONS, GETOPTION, CHECKOPTIONS
USE GETDATA_RAIN_ICE_OLD_MOD, ONLY: GETDATA_RAIN_ICE_OLD
USE COMPUTE_DIFF,    ONLY: DIFF
USE MODI_RAIN_ICE_OLD
USE MODD_DIMPHYEX,   ONLY: DIMPHYEX_t
USE MODD_PHYEX,      ONLY: PHYEX_t
USE STACK_MOD,       ONLY: STACK
USE MODE_MNH_ZWORK,  ONLY: ZMNH_STACK, IMNH_BLOCK, YMNH_STACK, INUMPIN
USE OMP_LIB
USE YOMHOOK, ONLY : LHOOK, DR_HOOK, JPHOOK
USE MODD_LES,        ONLY: TLES_t
#ifdef _OPENACC
USE MODD_UTIL_PHYEX_T, ONLY: COPY_PHYEX_T, WIPE_PHYEX_T
#endif


USE ISO_FORTRAN_ENV, ONLY: OUTPUT_UNIT

IMPLICIT NONE

INTEGER      :: KLEV
INTEGER      :: KRR

REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: PDZZ
REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: PRHODJ
REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: PRHODREF
REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: PEXNREF
REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: PPABSM
REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: PCIT, PCIT_OUT
REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: PCLDFR
REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: PTHT
REAL, ALLOCATABLE, DIMENSION(:,:,:,:) :: PRT
REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: PTHS, PTHS_OUT
REAL, ALLOCATABLE, DIMENSION(:,:,:,:) :: PRS, PRS_OUT
REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: PSIGS
REAL, ALLOCATABLE, DIMENSION(:,:)     :: PSEA
REAL, ALLOCATABLE, DIMENSION(:,:)     :: PTOWN

REAL, ALLOCATABLE, DIMENSION(:,:)     :: ZINPRC, ZINPRC_OUT
REAL, ALLOCATABLE, DIMENSION(:,:)     :: PINPRR, PINPRR_OUT
REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: PEVAP, PEVAP_OUT
REAL, ALLOCATABLE, DIMENSION(:,:)     :: PINPRS, PINPRS_OUT
REAL, ALLOCATABLE, DIMENSION(:,:)     :: PINPRG, PINPRG_OUT
REAL, ALLOCATABLE, DIMENSION(:,:,:,:) :: PFPR, PFPR_OUT

REAL, ALLOCATABLE, DIMENSION(:,:)     :: PINPRH, PINPRH_OUT

!spp stuff
REAL, ALLOCATABLE, dimension(:,:)   :: PICENU, PKGN_ACON, PKGN_SBGR
!ocnd2 stuff
REAL, ALLOCATABLE, DIMENSION(:,:,:) :: PICLDFR ! Ice cloud fraction
REAL, ALLOCATABLE, DIMENSION(:,:,:) :: PIFR    ! Ratio cloud ice moist part to dry part
REAL, ALLOCATABLE, DIMENSION(:,:,:) :: PSSIO   ! Super-saturation with respect to ice in the supersaturated fraction
REAL, ALLOCATABLE, DIMENSION(:,:,:) :: PSSIU   ! Sub-saturation with respect to ice in the subsaturated fraction
REAL, ALLOCATABLE, DIMENSION(:,:,:) :: PCLDROP, PIFNNC

LOGICAL, ALLOCATABLE, DIMENSION(:,:,:) :: LLMICRO

INTEGER :: NPROMA, NGPBLKS, NFLEVG
INTEGER :: JLON, JLEV
INTEGER, TARGET :: IBL

TYPE(DIMPHYEX_t)         :: D, D0
TYPE(PHYEX_t)            :: PHYEX
LOGICAL                  :: LLCHECK
LOGICAL                  :: LLCHECKDIFF
LOGICAL                  :: LLDIFF
INTEGER                  :: IBLOCK1, IBLOCK2
INTEGER                  :: ISTSZ(2), JBLK1, JBLK2
INTEGER                  :: NTID, ITID
INTEGER                  :: JRR
TYPE(TLES_t)             :: TLES

REAL, ALLOCATABLE, TARGET :: PSTACK8(:,:)
REAL(KIND=4), ALLOCATABLE, TARGET :: PSTACK4(:,:)
TYPE(STACK), TARGET :: YLSTACK

REAL(KIND=8) :: TS,TE
REAL(KIND=8) :: TSC, TEC, TSD, TED, ZTC, ZTD 
INTEGER(8) :: COUNTER, C_RATE
REAL(8) :: TIME_START_REAL, TIME_END_REAL
REAL(8) :: TIME_START_CPU, TIME_END_CPU
INTEGER :: ITIME, NTIME
INTEGER :: IRANK, ISIZE
LOGICAL :: LLVERBOSE, LLSTAT, LLBIND
REAL (KIND=JPHOOK) :: ZHOOK_HANDLE
CHARACTER(LEN=32) :: CLTEXT

INTEGER :: ISIZEMICRO
INTEGER :: KKA
INTEGER :: KKU
INTEGER :: KKL
INTEGER :: KSPLITR
LOGICAL :: OSEDIC
LOGICAL :: OCND2
LOGICAL :: LKOGAN
LOGICAL :: LMODICEDEP
LOGICAL :: OAERONRT, OAEIFN
CHARACTER(LEN=4) :: C_SEDIM
CHARACTER(LEN=4) :: CSUBG_AUCV_RC
LOGICAL :: OWARM
REAL    :: PTSTEP

CALL INITOPTIONS()
NGPBLKS = 150
CALL GETOPTION ("--blocks", NGPBLKS)
NPROMA = 32
CALL GETOPTION ("--nproma", NPROMA)
NFLEVG = 90
CALL GETOPTION ("--nflevg", NFLEVG)
CALL GETOPTION ("--check",  LLCHECK)
CALL GETOPTION ("--checkdiff",  LLCHECKDIFF)
IBLOCK1 = 1
CALL GETOPTION ("--check-block-1", IBLOCK1)
IBLOCK2 = NGPBLKS
CALL GETOPTION ("--check-block-2", IBLOCK2)
CALL GETOPTION ("--stat", LLSTAT)
NTIME = 1
CALL GETOPTION ("--times", NTIME)
LLVERBOSE = .FALSE.
CALL GETOPTION ("--verbose", LLVERBOSE)
CALL GETOPTION ("--bind", LLBIND)
CALL CHECKOPTIONS ()

LLDIFF = .FALSE.

IRANK = 0
ISIZE = 1
IF (LLBIND) THEN
  CALL LINUX_BIND      (IRANK, ISIZE)
  CALL LINUX_BIND_DUMP (IRANK, ISIZE)
ENDIF

IF(LLVERBOSE) THEN
  WRITE(OUTPUT_UNIT, *) 'N_GP_BLOCKS: ', NGPBLKS
  WRITE(OUTPUT_UNIT, *) 'N_PROMA:     ', NPROMA
  WRITE(OUTPUT_UNIT, *) 'N_LEVELS:    ', NFLEVG
  WRITE(OUTPUT_UNIT, *) 'TOTAL:       ', NFLEVG*NPROMA*NGPBLKS
ENDIF

CALL GETDATA_RAIN_ICE_OLD(NPROMA, NGPBLKS, NFLEVG, KRR, &
                          OSEDIC, OCND2, LKOGAN, LMODICEDEP, OWARM, &
                          KKA, KKU, KKL, KSPLITR, &
                          PTSTEP, C_SEDIM, CSUBG_AUCV_RC, &
                          PDZZ, PRHODJ, PRHODREF, &
                          PEXNREF, PPABSM, &
                          PCIT, PCIT_OUT, &
                          PCLDFR, &
                          PICLDFR, PSSIO, PSSIU, PIFR,  &
                          PTHT, PRT, PTHS, PTHS_OUT, &
                          PRS, PRS_OUT, &
                          PSIGS, PSEA, PTOWN,     &
                          PCLDROP, PIFNNC, &
                          ZINPRC, ZINPRC_OUT, &
                          PINPRR, PINPRR_OUT, &
                          PEVAP, PEVAP_OUT,        &
                          PINPRS, PINPRS_OUT, &
                          PINPRG, PINPRG_OUT,      &
                          PINPRH, PINPRH_OUT,      &
                          PICENU, PKGN_ACON, PKGN_SBGR, &
                          PFPR, PFPR_OUT, LLMICRO, LLVERBOSE)
KLEV = SIZE (PRS, 2)
OAERONRT = .FALSE.
OAEIFN = .FALSE.

IF (LLVERBOSE) PRINT *, " KLEV = ", KLEV, " KRR = ", KRR
  
IF (LLVERBOSE) THEN
  WRITE(OUTPUT_UNIT, *) 'OSEDIC:        ', OSEDIC
  WRITE(OUTPUT_UNIT, *) 'OCND2:         ', OCND2
  WRITE(OUTPUT_UNIT, *) 'LKOGAN:        ', LKOGAN
  WRITE(OUTPUT_UNIT, *) 'LMODICEDEP:    ', LMODICEDEP
  WRITE(OUTPUT_UNIT, *) 'OWARM:         ', OWARM
  WRITE(OUTPUT_UNIT, *) 'KKA:           ', KKA
  WRITE(OUTPUT_UNIT, *) 'KKU:           ', KKU
  WRITE(OUTPUT_UNIT, *) 'KKL:           ', KKL
  WRITE(OUTPUT_UNIT, *) 'KSPLITR:       ', KSPLITR
  WRITE(OUTPUT_UNIT, *) 'PTSTEP:        ', PTSTEP
  WRITE(OUTPUT_UNIT, *) 'C_SEDIM:       ', C_SEDIM
  WRITE(OUTPUT_UNIT, *) 'CSUBG_AUCV_RC: ', CSUBG_AUCV_RC
ENDIF

PRINT *, " NPROMA = ", NPROMA, " KLEV = ", KLEV, " NGPBLKS = ", NGPBLKS

CALL INIT_PHYEX(KRR, PHYEX, OWARM, OSEDIC, OCND2, C_SEDIM, CSUBG_AUCV_RC, PTSTEP)
TLES%LLES=.FALSE.

D0%NIT  = NPROMA
D0%NIB  = 1
D0%NIE  = NPROMA
D0%NJT  = 1
D0%NJB  = 1
D0%NJE  = 1
D0%NIJT = D0%NIT * D0%NJT
D0%NIJB = 1
D0%NIJE = NPROMA
D0%NKL  = KKL
D0%NKT  = KLEV
D0%NKA  = KLEV
D0%NKU  = 1
D0%NKB  = KLEV 
D0%NKE  = 1
D0%NKTB = 1
D0%NKTE = KLEV

ISTSZ=0
ISTSZ(KIND(LLMICRO)/4) = NPROMA * 3 * KLEV
ISTSZ(KIND(PRHODJ)/4) = ISTSZ(KIND(PRHODJ)/4) + NPROMA * 22 * KLEV
#ifdef USE_STACK
#if defined(USE_COLCALL) && defined(_OPENACC)
ISTSZ(:) = ISTSZ(:) * NPROMA
#endif
#else
ISTSZ(2) = ISTSZ(2) + CEILING(ISTSZ(1) / 2.)
ISTSZ(1) = 0
#endif
ALLOCATE (PSTACK4 (ISTSZ(1), NGPBLKS))
ALLOCATE (PSTACK8 (ISTSZ(2), NGPBLKS))
ZMNH_STACK => PSTACK8

TS = OMP_GET_WTIME ()

ZTD = 0.
ZTC = 0.

CALL INIT_GMICRO(D0, KRR, NGPBLKS, LLMICRO, PRT, PSSIO, OCND2)

IF (LHOOK) CALL DR_HOOK ('MAIN',0,ZHOOK_HANDLE)

CALL CPU_TIME(TIME_START_CPU)
CALL SYSTEM_CLOCK(COUNT=COUNTER, COUNT_RATE=C_RATE)
TIME_START_REAL = REAL(COUNTER,8)/C_RATE

DO ITIME = 1, NTIME

  TSD = OMP_GET_WTIME ()

#ifdef _OPENACC
  CALL COPY_PHYEX_T(PHYEX)
#endif

!$acc data &
!$acc      & copyin  (D0, TLES, LKOGAN, LMODICEDEP, KKA, KKU, KKL, KSPLITR, PTSTEP, KRR, ISIZEMICRO, &
!$acc      &          LLMICRO, PDZZ, PRHODJ, PRHODREF, PEXNREF, PPABSM, PCLDFR, PICLDFR, PSSIO, PSSIU, &
!$acc      &          OAERONRT, OAEIFN, &
!$acc      &          PTHT, PRT, PSIGS, PSEA, PTOWN, PICENU, PKGN_ACON, PKGN_SBGR) &
!$acc      & copy    (PCIT, PIFR, PTHS, PRS) &
!$acc      & copyout (ZINPRC, PINPRR, PEVAP, PINPRS, PINPRG, PFPR) &
!$acc      & create  (PSTACK4, PSTACK8) 

  TSC = OMP_GET_WTIME ()

#ifdef USE_OPENMP
!$OMP PARALLEL PRIVATE (D, YLSTACK, ITID, JBLK1, JBLK2, ISIZE, ISIZEMICRO)

  NTID = OMP_GET_MAX_THREADS ()
  ITID = OMP_GET_THREAD_NUM ()
  JBLK1 = 1 +  (NGPBLKS * (ITID+0)) / NTID
  JBLK2 =      (NGPBLKS * (ITID+1)) / NTID
#else
  JBLK1 = 1
  JBLK2 = NGPBLKS
#endif

  D = D0

!$acc parallel loop gang vector present (PHYEX) private (YLSTACK, IBL, JLON, D, ISIZEMICRO) collapse (2)

  DO IBL = JBLK1, JBLK2

#ifdef USE_COLCALL
  DO JLON = 1, NPROMA
    D = D0
    D%NIB = JLON
    D%NIE = JLON
    D%NIJB = JLON
    D%NIJE = JLON
    ISIZEMICRO = COUNT(LLMICRO(JLON,:,IBL))
#else
    ISIZEMICRO = COUNT(LLMICRO(:,:,IBL))
#endif

#ifdef USE_STACK
    !Using cray pointers, AROME mechanism
#if defined(USE_COLCALL) && defined(_OPENACC)
    !Each point must have its own stack, otherwise the different threads will use the same
    !memory region during the packing operation
    YLSTACK%L(1) = LOC (PSTACK4 (1, IBL)) + CEILING(ISTSZ(1) * KIND (PSTACK4) / NPROMA / 4.) * 4 * (JLON - 1)
    YLSTACK%U(1) = YLSTACK%L(1) + FLOOR(ISTSZ(1) * KIND (PSTACK4) / NPROMA / 4.) * 4
    YLSTACK%L(2) = LOC (PSTACK8 (1, IBL)) + CEILING(ISTSZ(2) * KIND (PSTACK8) / NPROMA / 8.) * 8 * (JLON - 1)
    YLSTACK%U(2) = YLSTACK%L(2) + FLOOR(ISTSZ(2) * KIND (PSTACK8) / NPROMA / 8.) * 8
#else
    YLSTACK%L(1) = LOC (PSTACK4 (1, IBL))
    YLSTACK%U(1) = YLSTACK%L(1) + ISTSZ(1) * KIND (PSTACK4)
    YLSTACK%L(2) = LOC (PSTACK8 (1, IBL))
    YLSTACK%U(2) = YLSTACK%L(2) + ISTSZ(2) * KIND (PSTACK8)
#endif
#else
    !Using fortran indexing, Meso-NH mechanism
    YLSTACK%L(2) = 1
    YLSTACK%U(2) = ISTSZ(2)
    IMNH_BLOCK => IBL
    YMNH_STACK => YLSTACK
    INUMPIN = 0
#endif

      CALL RAIN_ICE_OLD(D=D, CST=PHYEX%CST, PARAMI=PHYEX%PARAM_ICEN,                                   &
                        ICEP=PHYEX%RAIN_ICE_PARAMN, ICED=PHYEX%RAIN_ICE_DESCRN, BUCONF=PHYEX%MISC%TBUCONF, TLES=TLES,       &
                        OSEDIC=PHYEX%PARAM_ICEN%LSEDIC, OCND2=PHYEX%PARAM_ICEN%LOCND2,     &
                        LKOGAN=LKOGAN, LMODICEDEP=LMODICEDEP,                              &
                        HSEDIM=PHYEX%PARAM_ICEN%CSEDIM, HSUBG_AUCV_RC=PHYEX%PARAM_ICEN%CSUBG_AUCV_RC, OWARM=PHYEX%PARAM_ICEN%LWARM,&
                        KKA=KKA, KKU=KKU, KKL=KKL,                                         &
                        KSPLITR=KSPLITR, PTSTEP=2*PTSTEP, KRR=KRR,                         &
                        KSIZE=ISIZEMICRO, GMICRO=LLMICRO(:,:,IBL),                                &
                        PDZZ=PDZZ(:,:,IBL), PRHODJ=PRHODJ(:,:,IBL), PRHODREF=PRHODREF(:,:,IBL),  &
                        PEXNREF=PEXNREF(:,:,IBL), PPABST=PPABSM(:,:,IBL),                      &
                        PCIT=PCIT(:,:,IBL), PCLDFR=PCLDFR(:,:,IBL),                            &
                        PICLDFR=PICLDFR(:,:,IBL), PSSIO=PSSIO(:,:,IBL), PSSIU=PSSIU(:,:,IBL),    &
                        PIFR=PIFR(:,:,IBL),                                                  &
                        PTHT=PTHT(:,:,IBL),                                                  &
                        PRVT=PRT(:,:,1,IBL), PRCT=PRT(:,:,2,IBL), PRRT=PRT(:,:,3,IBL),           &
                        PRIT=PRT(:,:,4,IBL), PRST=PRT(:,:,5,IBL), PRGT=PRT(:,:,6,IBL),           &
                        PTHS=PTHS(:,:,IBL),                                                  &
                        PRVS=PRS(:,:,1,IBL), PRCS=PRS(:,:,2,IBL), PRRS=PRS(:,:,3,IBL),           &
                        PRIS=PRS(:,:,4,IBL), PRSS=PRS(:,:,5,IBL), PRGS=PRS(:,:,6,IBL),           &
                        PINPRC=ZINPRC(:,IBL), PINPRR=PINPRR(:,IBL), PEVAP3D=PEVAP(:,:,IBL),      &
                        PINPRS=PINPRS(:,IBL), PINPRG=PINPRG(:,IBL), PSIGS=PSIGS(:,:,IBL),        &
                        PSEA=PSEA(:,IBL), PTOWN=PTOWN(:,IBL),                                  &
                        OAERONRT=OAERONRT, OAEIFN=OAEIFN, &
                        PCLDROP=PCLDROP(:,:,IBL), PIFNNC=PIFNNC(:,:,IBL), &
                        TBUDGETS=PHYEX%MISC%YLBUDGET, KBUDGETS=PHYEX%MISC%NBUDGET,                        &
                        PICENU=PICENU(:,IBL),                                                &
                        PKGN_ACON=PKGN_ACON(:,IBL), PKGN_SBGR=PKGN_SBGR(:,IBL),                &
                        PFPR=PFPR(:,:,:,IBL) &
#ifdef USE_STACK                                                                                                                    
                        , YDSTACK=YLSTACK &                                                                                                           
#endif
                        )

#ifdef USE_COLCALL
    ENDDO
#endif

  ENDDO

#ifdef USE_OPENMP
!$OMP END PARALLEL
#endif

!$acc end parallel loop

  TEC = OMP_GET_WTIME ()

!$acc end data

#ifdef _OPENACC
  CALL WIPE_PHYEX_T(PHYEX)
#endif

  TED = OMP_GET_WTIME ()

  ZTC = ZTC + (TEC - TSC)
  ZTD = ZTD + (TED - TSD)

ENDDO

IF (LHOOK) CALL DR_HOOK ('MAIN',1,ZHOOK_HANDLE)

TE = OMP_GET_WTIME()

WRITE (*,'(A,F8.2,A)') 'elapsed time : ',TE-TS,' s'
WRITE (*,'(A,F8.4,A)') '          i.e. ',1000.*(TE-TS)/(NPROMA*NGPBLKS)/NTIME,' ms/gp'

PRINT *, " ZTD = ", ZTD, ZTD / REAL (NPROMA*NGPBLKS*NTIME)
PRINT *, " ZTC = ", ZTC, ZTC / REAL (NPROMA*NGPBLKS*NTIME)


CALL CPU_TIME(TIME_END_CPU)
CALL SYSTEM_CLOCK(COUNT=COUNTER, COUNT_RATE=C_RATE)
TIME_END_REAL = REAL(COUNTER,8)/C_RATE

IF(LLVERBOSE) THEN
  WRITE(OUTPUT_UNIT, *)
  WRITE(OUTPUT_UNIT, *) 'TOTAL TIME: ', TIME_END_REAL - TIME_START_REAL
ENDIF

IF (LLCHECK .OR. LLSTAT .OR. LLCHECKDIFF) THEN
  DO IBL = IBLOCK1, IBLOCK2
    PRINT *, " IBL = ", IBL
    DO JRR=1, KRR
      WRITE (CLTEXT, '("PRS JRR=",I3.3)') JRR
      CALL DIFF (CLTEXT,   PRS_OUT       (:,:,JRR,IBL), PRS      (:,:,JRR,IBL), LLSTAT, LLCHECK, NPROMA, LLCHECKDIFF, LLDIFF)
      IF(JRR>=2) THEN
        WRITE (CLTEXT, '("PFPR JRR=",I3.3)') JRR
        CALL DIFF (CLTEXT, PFPR_OUT      (:,:,JRR,IBL), PFPR     (:,:,JRR,IBL), LLSTAT, LLCHECK, NPROMA, LLCHECKDIFF, LLDIFF)
      ENDIF
    ENDDO
    CALL DIFF ("PCIT",     PCIT_OUT      (:,:,IBL), PCIT     (:,:,IBL), LLSTAT, LLCHECK, NPROMA, LLCHECKDIFF, LLDIFF)
    CALL DIFF ("ZINPRC",   ZINPRC_OUT    (:,IBL),   ZINPRC   (:,IBL)  , LLSTAT, LLCHECK, NPROMA, LLCHECKDIFF, LLDIFF)
    CALL DIFF ("PINPRRRS", PINPRR_OUT    (:,IBL),   PINPRR   (:,IBL)  , LLSTAT, LLCHECK, NPROMA, LLCHECKDIFF, LLDIFF)
    CALL DIFF ("PEVAP",    PEVAP_OUT     (:,:,IBL), PEVAP    (:,:,IBL), LLSTAT, LLCHECK, NPROMA, LLCHECKDIFF, LLDIFF)
    CALL DIFF ("PINPRS",   PINPRS_OUT    (:,IBL),   PINPRS   (:,IBL)  , LLSTAT, LLCHECK, NPROMA, LLCHECKDIFF, LLDIFF)
    CALL DIFF ("PINPRG",   PINPRG_OUT    (:,IBL),   PINPRG   (:,IBL)  , LLSTAT, LLCHECK, NPROMA, LLCHECKDIFF, LLDIFF)
    CALL DIFF ("PTHS",     PTHS_OUT      (:,:,IBL), PTHS     (:,:,IBL), LLSTAT, LLCHECK, NPROMA, LLCHECKDIFF, LLDIFF)
  ENDDO
ENDIF

IF (LLCHECKDIFF) THEN
  IF (LLDIFF) THEN
    PRINT*, "THERE ARE DIFF SOMEWHERE"
  ELSE
    PRINT*, "THERE IS NO DIFF AT ALL"
  ENDIF
ENDIF

STOP

CONTAINS

SUBROUTINE INIT_PHYEX(KRR, PHYEX, LDWARM, LDSEDIC, LDCND2, C_SEDIM, CSUBG_AUCV_RC, PTSTEP)

USE MODD_BUDGET, ONLY: TBUCONF_ASSOCIATE, NBUDGET_RH, TBUCONF, LBU_ENABLE, LBUDGET_U, LBUDGET_V, LBUDGET_W, LBUDGET_TH, &
                       LBUDGET_TKE, LBUDGET_RV, LBUDGET_RC, LBUDGET_RR, LBUDGET_RI, LBUDGET_RS, LBUDGET_RG, LBUDGET_RH, LBUDGET_SV
USE MODD_PHYEX, ONLY: PHYEX_t
USE MODI_INI_PHYEX, ONLY: INI_PHYEX

IMPLICIT NONE

! -----------------------------------------------------------------------
!     DUMMY VARIABLES
INTEGER,          INTENT(IN)  :: KRR
TYPE(PHYEX_t),    INTENT(OUT) :: PHYEX
LOGICAL,          INTENT(IN)  :: LDWARM
LOGICAL,          INTENT(IN)  :: LDSEDIC
LOGICAL,          INTENT(IN)  :: LDCND2
CHARACTER(LEN=4), INTENT(IN)  :: C_SEDIM
CHARACTER(LEN=4), INTENT(IN)  :: CSUBG_AUCV_RC
REAL,             INTENT(IN)  :: PTSTEP

!-----------------------------------------------------------------------
!    LOCAL VARIABLES
INTEGER :: IULOUT, JRR
REAL :: ZDZMIN
CHARACTER(LEN=6) :: CPROGRAM
CHARACTER(LEN=4) :: CMICRO, CSCONV, CTURB
! -----------------------------------------------------------------------

IULOUT=20
CPROGRAM='AROME'
ZDZMIN=20.
CMICRO='ICE3'
CSCONV='NONE'
CTURB='TKEL'
PHYEX%MISC%TPFILE%NLU=0

!Default values
CALL INI_PHYEX(CPROGRAM, PHYEX%MISC%TPFILE, .TRUE., IULOUT, 0, 1, &
              &PTSTEP, ZDZMIN, &
              &CMICRO, CSCONV, CTURB, &
              &LDDEFAULTVAL=.TRUE., LDREADNAM=.FALSE., LDCHECK=.FALSE., KPRINT=0, LDINIT=.FALSE., &
              &PHYEX_OUT=PHYEX)

!Control parameters
PHYEX%MISC%PTSTEP       = 2*PTSTEP
PHYEX%MISC%KRR          = KRR

!Emulate the namelist reading
!PHYEX%PARAM_ICEN%LCRIAUTI=.TRUE.
!PHYEX%PARAM_ICEN%XCRIAUTI_NAM=0.2E-3
!PHYEX%PARAM_ICEN%XT0CRIAUTI_NAM=-5.
!PHYEX%PARAM_ICEN%XCRIAUTC_NAM=0.1E-2
PHYEX%PARAM_ICEN%LOCND2=LDCND2
PHYEX%PARAM_ICEN%CSEDIM=C_SEDIM
PHYEX%PARAM_ICEN%LWARM=LDWARM
PHYEX%PARAM_ICEN%LSEDIC=LDSEDIC
!PHYEX%PARAM_ICEN%CSNOWRIMING='M90 '
!PHYEX%PARAM_ICEN%XFRACM90=0.1 ! Fraction used for the Murakami 1990 formulation
!PHYEX%PARAM_ICEN%LCONVHG=.TRUE. ! TRUE to allow the conversion from hail to graupel
!PHYEX%PARAM_ICEN%LCRFLIMIT=.TRUE. !True to limit rain contact freezing to possible heat exchange
!PHYEX%PARAM_ICEN%LFEEDBACKT=.TRUE. ! When .TRUE. feed back on temperature is taken into account
!PHYEX%PARAM_ICEN%LEVLIMIT=.TRUE.   ! When .TRUE. water vapour pressure is limited by saturation
!PHYEX%PARAM_ICEN%LNULLWETG=.TRUE.  ! When .TRUE. graupel wet growth is activated with null rate (to allow water shedding)
!PHYEX%PARAM_ICEN%LWETGPOST=.TRUE.  ! When .TRUE. graupel wet growth is activated with positive temperature (to allow water shedding)
!PHYEX%PARAM_ICEN%LNULLWETH=.TRUE.  ! Same as LNULLWETG but for hail
!PHYEX%PARAM_ICEN%LWETHPOST=.TRUE.  ! Same as LWETGPOST but for hail
!PHYEX%PARAM_ICEN%LSEDIM_AFTER=.FALSE. ! Sedimentation done after microphysics
!PHYEX%PARAM_ICEN%XSPLIT_MAXCFL=0.8
!PHYEX%PARAM_ICEN%LDEPOSC=.FALSE.  ! water deposition on vegetation
!PHYEX%PARAM_ICEN%XVDEPOSC=0.02    ! deposition speed (2 cm.s-1)
!PHYEX%PARAM_ICEN%CSUBG_RC_RR_ACCR='NONE'
!PHYEX%PARAM_ICEN%CSUBG_RR_EVAP='NONE'
!PHYEX%PARAM_ICEN%CSUBG_PR_PDF='SIGM'
PHYEX%PARAM_ICEN%CSUBG_AUCV_RC=CSUBG_AUCV_RC

!Param initialisation
CALL INI_PHYEX(CPROGRAM, PHYEX%MISC%TPFILE, .TRUE., IULOUT, 0, 1, &
              &PTSTEP, ZDZMIN, &
              &CMICRO, CSCONV, CTURB, &
              &LDDEFAULTVAL=.FALSE., LDREADNAM=.FALSE., LDCHECK=.TRUE., KPRINT=2, LDINIT=.TRUE., &
              &PHYEX_IN=PHYEX, PHYEX_OUT=PHYEX)

!Budgets
CALL TBUCONF_ASSOCIATE
PHYEX%MISC%NBUDGET=NBUDGET_RH
DO JRR=1, PHYEX%MISC%NBUDGET
  PHYEX%MISC%YLBUDGET(JRR)%NBUDGET=JRR
ENDDO
LBU_ENABLE=.FALSE.                                                                                                       
LBUDGET_U=.FALSE.
LBUDGET_V=.FALSE.
LBUDGET_W=.FALSE.
LBUDGET_TH=.FALSE.
LBUDGET_TKE=.FALSE.
LBUDGET_RV=.FALSE.
LBUDGET_RC=.FALSE.
LBUDGET_RR=.FALSE.
LBUDGET_RI=.FALSE.
LBUDGET_RS=.FALSE.
LBUDGET_RG=.FALSE.
LBUDGET_RH=.FALSE.
LBUDGET_SV=.FALSE.
PHYEX%MISC%TBUCONF=TBUCONF

END SUBROUTINE INIT_PHYEX

SUBROUTINE INIT_GMICRO(D, KRR, NGPBLKS, ODMICRO, PRT, PSSIO, OCND2)

  USE MODD_DIMPHYEX, ONLY: DIMPHYEX_T
  USE MODD_RAIN_ICE_DESCR_N, ONLY: XRTMIN
  USE MODD_RAIN_ICE_PARAM_N, ONLY: XFRMIN
  USE ISO_FORTRAN_ENV, ONLY: OUTPUT_UNIT

  IMPLICIT NONE

  TYPE(DIMPHYEX_T) :: D

  INTEGER, INTENT(IN) :: KRR, NGPBLKS
  LOGICAL, DIMENSION(D%NIT, D%NKT, NGPBLKS), INTENT(INOUT) :: ODMICRO

  REAL, DIMENSION(D%NIT, D%NKT, KRR, NGPBLKS), INTENT(IN) :: PRT
  REAL, DIMENSION(D%NIT, D%NKT, NGPBLKS), INTENT(IN) :: PSSIO

  LOGICAL, INTENT(IN) :: OCND2

  INTEGER :: I, K, IKRR, IBLOCK
  REAL    :: ZTHR

  DO IBLOCK = 1, NGPBLKS

    IF (OCND2) THEN
      DO K = 1, D%NKT
        DO I = 1, D%NIT
          ODMICRO(I, K, IBLOCK) = ODMICRO(I, K, IBLOCK) .OR. PSSIO(I, K, IBLOCK) > XFRMIN(12)
        ENDDO
      ENDDO
    ENDIF

    DO IKRR = 2, KRR
      IF (OCND2) THEN
        ZTHR = XFRMIN(13)
      ELSE
        ZTHR = XRTMIN(IKRR)
      ENDIF
      DO K = 1, D%NKT
        DO I = 1, D%NIT
          ODMICRO(I, K, IBLOCK) = ODMICRO(I, K, IBLOCK) .OR. PRT(I, K, IKRR, IBLOCK) > XFRMIN(13)
        ENDDO
      ENDDO
    ENDDO

  ENDDO

END SUBROUTINE INIT_GMICRO

END PROGRAM
