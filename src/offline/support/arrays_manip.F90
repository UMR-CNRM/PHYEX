MODULE ARRAYS_MANIP

USE OMP_LIB
USE IEEE_ARITHMETIC, ONLY : IEEE_SIGNALING_NAN, IEEE_VALUE
USE PARKIND1, ONLY: JPRD

IMPLICIT NONE

INTERFACE REPLICATE
  MODULE PROCEDURE REPLICATER1
  MODULE PROCEDURE REPLICATER2
  MODULE PROCEDURE REPLICATER3
  MODULE PROCEDURE REPLICATEL2
  MODULE PROCEDURE REPLICATEL1
END INTERFACE

INTERFACE NPROMIZE
  MODULE PROCEDURE NPROMIZER2
  MODULE PROCEDURE NPROMIZER3
  MODULE PROCEDURE NPROMIZER4
  MODULE PROCEDURE NPROMIZEL3
  MODULE PROCEDURE NPROMIZEI2
END INTERFACE                   

INTERFACE INTERPOLATE
  MODULE PROCEDURE INTERPOLATER3
  MODULE PROCEDURE INTERPOLATER4
  MODULE PROCEDURE INTERPOLATEL3
END INTERFACE

INTERFACE SET
  MODULE PROCEDURE SETR2
  MODULE PROCEDURE SETR3
  MODULE PROCEDURE SETR4
  MODULE PROCEDURE SETI2
END INTERFACE

REAL, SAVE :: XINVALID
INTEGER, SAVE :: NINVALID

CONTAINS

SUBROUTINE SETUP()
  !XINVALID = IEEE_VALUE (1., IEEE_SIGNALING_NAN)
  XINVALID = HUGE(1.)
  NINVALID = HUGE(1)
END SUBROUTINE SETUP

SUBROUTINE REPLICATER3 (KOFF, P)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KOFF
REAL(KIND=JPRD), INTENT(INOUT)    :: P (:,:,:)

INTEGER :: I, J

DO I = KOFF+1, SIZE (P, 1)
  J = 1 + MODULO (I - 1, KOFF)
  P (I, :, :) = P (J, :, :)
ENDDO

END SUBROUTINE

SUBROUTINE REPLICATER2 (KOFF, P)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KOFF
REAL(KIND=JPRD), INTENT(INOUT)    :: P (:,:)

INTEGER :: I, J

DO I = KOFF+1, SIZE (P, 1)
  J = 1 + MODULO (I - 1, KOFF)
  P (I, :) = P (J, :)
ENDDO

END SUBROUTINE

SUBROUTINE REPLICATEL1 (KOFF, K)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KOFF
INTEGER, INTENT(INOUT) :: K (:)

INTEGER :: I, J

DO I = KOFF+1, SIZE (K, 1)
  J = 1 + MODULO (I - 1, KOFF)
  K (I) = K (J)
ENDDO

END SUBROUTINE

SUBROUTINE REPLICATER1 (KOFF, P)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KOFF
REAL(KIND=JPRD), INTENT(INOUT)    :: P (:)

INTEGER :: I, J

DO I = KOFF+1, SIZE (P, 1)
  J = 1 + MODULO (I - 1, KOFF)
  P (I) = P (J)
ENDDO

END SUBROUTINE

SUBROUTINE REPLICATEL2 (KOFF, L)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KOFF
LOGICAL, INTENT(INOUT) :: L (:,:)

INTEGER :: I, J

DO I = KOFF+1, SIZE (L, 1)
  J = 1 + MODULO (I - 1, KOFF)
  L (I, :) = L (J, :)
ENDDO

END SUBROUTINE

SUBROUTINE NPROMIZEI2 (KPROMA, KI, KO)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KPROMA
INTEGER, INTENT (IN)  :: KI (:,:) 
INTEGER, INTENT (OUT) :: KO (:,:)

INTEGER :: IGPBLK, IGPTOT, IGP, JLON, JIDIA, JFDIA, IBL

IF (SIZE (KI, 2) /= 1) STOP 1

IGPTOT = SIZE (KI, 1)
IGPBLK = 1 + (IGPTOT-1) / KPROMA

DO IGP = 1, IGPTOT, KPROMA
  IBL = 1 + (IGP - 1) / KPROMA
  JIDIA = 1
  JFDIA = MIN (KPROMA, IGPTOT - (IBL - 1) * KPROMA)

  DO JLON = JIDIA, JFDIA
    KO (JLON, IBL) = KI (IGP + (JLON - 1), 1)
  ENDDO

  DO JLON = JFDIA+1, KPROMA
    KO (JLON, IBL) = KO (JFDIA, IBL)
  ENDDO

ENDDO

END SUBROUTINE

SUBROUTINE NPROMIZER2 (KPROMA, PI, PO)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KPROMA
REAL(KIND=JPRD), INTENT (IN)  :: PI (:,:) 
REAL, INTENT (OUT) :: PO (:,:)

INTEGER :: IGPBLK, IGPTOT, IGP, JLON, JIDIA, JFDIA, IBL

IF (SIZE (PI, 2) /= 1) STOP 1

IGPTOT = SIZE (PI, 1)
IGPBLK = 1 + (IGPTOT-1) / KPROMA

DO IGP = 1, IGPTOT, KPROMA
  IBL = 1 + (IGP - 1) / KPROMA
  JIDIA = 1
  JFDIA = MIN (KPROMA, IGPTOT - (IBL - 1) * KPROMA)

  DO JLON = JIDIA, JFDIA
    PO (JLON, IBL) = PI (IGP + (JLON - 1), 1)
  ENDDO

  DO JLON = JFDIA+1, KPROMA
    PO (JLON, IBL) = PO (JFDIA, IBL)
  ENDDO

ENDDO

END SUBROUTINE

SUBROUTINE NPROMIZER3 (KPROMA, PI, PO)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KPROMA
REAL(KIND=JPRD), INTENT (IN)  :: PI (:,:,:) 
REAL, INTENT (OUT) :: PO (:,:,:)

INTEGER :: IGPBLK, IGPTOT, IGP, JLON, JIDIA, JFDIA, IBL

IF (SIZE (PI, 3) /= 1) STOP 1

IGPTOT = SIZE (PI, 1)
IGPBLK = 1 + (IGPTOT-1) / KPROMA

DO IGP = 1, IGPTOT, KPROMA
  IBL = 1 + (IGP - 1) / KPROMA
  JIDIA = 1
  JFDIA = MIN (KPROMA, IGPTOT - (IBL - 1) * KPROMA)

  DO JLON = JIDIA, JFDIA
    PO (JLON, :, IBL) = PI (IGP + (JLON - 1), :, 1)
  ENDDO

  DO JLON = JFDIA+1, KPROMA
    PO (JLON, :, IBL) = PO (JFDIA, :, IBL)
  ENDDO

ENDDO

END SUBROUTINE

SUBROUTINE NPROMIZER4 (KPROMA, PI, PO)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KPROMA
REAL(KIND=JPRD), INTENT (IN)  :: PI (:,:,:,:) 
REAL, INTENT (OUT) :: PO (:,:,:,:)

INTEGER :: IGPBLK, IGPTOT, IGP, JLON, JIDIA, JFDIA, IBL

IF (SIZE (PI, 4) /= 1) STOP 1

IGPTOT = SIZE (PI, 1)
IGPBLK = 1 + (IGPTOT-1) / KPROMA

DO IGP = 1, IGPTOT, KPROMA
  IBL = 1 + (IGP - 1) / KPROMA
  JIDIA = 1
  JFDIA = MIN (KPROMA, IGPTOT - (IBL - 1) * KPROMA)

  DO JLON = JIDIA, JFDIA
    PO (JLON, :, :, IBL) = PI (IGP + (JLON - 1), :, :, 1)
  ENDDO

  DO JLON = JFDIA+1, KPROMA
    PO (JLON, :, :, IBL) = PI (JFDIA, :, :, IBL)
  ENDDO

ENDDO

END SUBROUTINE

SUBROUTINE NPROMIZEL3 (KPROMA, LI, LO)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KPROMA
LOGICAL, INTENT (IN)  :: LI (:,:,:) 
LOGICAL, INTENT (OUT) :: LO (:,:,:)

INTEGER :: IGPBLK, IGPTOT, IGP, JLON, JIDIA, JFDIA, IBL

IF (SIZE (LI, 3) /= 1) STOP 1

IGPTOT = SIZE (LI, 1)
IGPBLK = 1 + (IGPTOT-1) / KPROMA

DO IGP = 1, IGPTOT, KPROMA
  IBL = 1 + (IGP - 1) / KPROMA
  JIDIA = 1
  JFDIA = MIN (KPROMA, IGPTOT - (IBL - 1) * KPROMA)

  DO JLON = JIDIA, JFDIA
    LO (JLON, :, IBL) = LI (IGP + (JLON - 1), :, 1)
  ENDDO

  DO JLON = JFDIA+1, KPROMA
    LO (JLON, :, IBL) = LI (JFDIA, :, IBL)
  ENDDO

ENDDO

END SUBROUTINE

SUBROUTINE INTERPOLATER3 (KFLEVG, KOFF, P)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KFLEVG, KOFF
REAL(KIND=JPRD), INTENT(INOUT), ALLOCATABLE :: P (:,:,:)
REAL(KIND=JPRD) :: Z (LBOUND (P, 1):UBOUND (P, 1), &
                    & LBOUND (P, 2):UBOUND (P, 2), &
                    & LBOUND (P, 3):UBOUND (P, 3))
INTEGER :: ILEV1A, ILEV1B, ILEV2, NLEV1, NLEV2
REAL :: ZWA, ZWB, ZLEV1, ZLEV2

Z = P

NLEV1 = SIZE (P, 2)
NLEV2 = KFLEVG

DEALLOCATE (P)

ALLOCATE (P (LBOUND (Z, 1):UBOUND (Z, 1), &
           & KFLEVG, &
           & LBOUND (Z, 3):UBOUND (Z, 3)))

DO ILEV2 = 1, NLEV2
  ZLEV2 = REAL (ILEV2 - 1) / REAL (NLEV2 -1)
  ZLEV1 = 1. + ZLEV2 * REAL (NLEV1 - 1)
  ILEV1B = MIN (CEILING (ZLEV1), NLEV1)
  ILEV1A = MAX (FLOOR   (ZLEV1),     1)

  IF (ILEV1A == ILEV1B) THEN
    ZWA = 1.
    ZWB = 0.
  ELSE
    ZWA = REAL (ILEV1B) - ZLEV1
    ZWB = ZLEV1 - REAL (ILEV1A)
  ENDIF

! WRITE (*, '(" ZLEV2 = ",E12.5," ZLEV1 = ",E12.5," ILEV2 = ",I4," ILEV1A = ",I4," ZWA = ",E12.5," ILEV1B = ",I4," ZWB = ",E12.5)') &
!   & ZLEV2, ZLEV1, ILEV2, ILEV1A, ZWA, ILEV1B, ZWB

  P (1:KOFF, ILEV2, :) = ZWA * Z (1:KOFF, ILEV1A, :) + ZWB * Z (1:KOFF, ILEV1B, :) 
ENDDO

END SUBROUTINE

SUBROUTINE INTERPOLATER4 (KFLEVG, KOFF, P)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KFLEVG, KOFF
REAL(KIND=JPRD), INTENT(INOUT), ALLOCATABLE :: P (:,:,:,:)
REAL(KIND=JPRD) :: Z (LBOUND (P, 1):UBOUND (P, 1), &
                    & LBOUND (P, 2):UBOUND (P, 2), &
                    & LBOUND (P, 3):UBOUND (P, 3), &
                    & LBOUND (P, 4):UBOUND (P, 4))
INTEGER :: ILEV1A, ILEV1B, ILEV2, NLEV1, NLEV2
REAL :: ZWA, ZWB, ZLEV1, ZLEV2

Z = P

NLEV1 = SIZE (P, 2)
NLEV2 = KFLEVG

DEALLOCATE (P)

ALLOCATE (P (LBOUND (Z, 1):UBOUND (Z, 1), &
           & KFLEVG, &
           & LBOUND (Z, 3):UBOUND (Z, 3), &
           & LBOUND (Z, 4):UBOUND (Z, 4)))

DO ILEV2 = 1, NLEV2
  ZLEV2 = REAL (ILEV2 - 1) / REAL (NLEV2 -1)
  ZLEV1 = 1. + ZLEV2 * REAL (NLEV1 - 1)
  ILEV1B = MIN (CEILING (ZLEV1), NLEV1)
  ILEV1A = MAX (FLOOR   (ZLEV1),     1)

  IF (ILEV1A == ILEV1B) THEN
    ZWA = 1.
    ZWB = 0.
  ELSE
    ZWA = REAL (ILEV1B) - ZLEV1
    ZWB = ZLEV1 - REAL (ILEV1A)
  ENDIF

! WRITE (*, '(" ZLEV2 = ",E12.5," ZLEV1 = ",E12.5," ILEV2 = ",I4," ILEV1A = ",I4," ZWA = ",E12.5," ILEV1B = ",I4," ZWB = ",E12.5)') &
!   & ZLEV2, ZLEV1, ILEV2, ILEV1A, ZWA, ILEV1B, ZWB

  P (1:KOFF, ILEV2, :, :) = ZWA * Z (1:KOFF, ILEV1A, :, :) + ZWB * Z (1:KOFF, ILEV1B, :, :) 
ENDDO

END SUBROUTINE

SUBROUTINE INTERPOLATEL3 (KFLEVG, KOFF, L)
IMPLICIT NONE

INTEGER, INTENT(IN) :: KFLEVG, KOFF
LOGICAL, INTENT(INOUT), ALLOCATABLE :: L (:,:,:)
LOGICAL :: Z (LBOUND (L, 1):UBOUND (L, 1), &
            & LBOUND (L, 2):UBOUND (L, 2), &
            & LBOUND (L, 3):UBOUND (L, 3))
INTEGER :: ILEV1A, ILEV1B, ILEV2, NLEV1, NLEV2
REAL :: ZWA, ZWB, ZLEV1, ZLEV2

Z = L

NLEV1 = SIZE (L, 2)
NLEV2 = KFLEVG

DEALLOCATE (L)

ALLOCATE (L (LBOUND (Z, 1):UBOUND (Z, 1), &
           & KFLEVG, &
           & LBOUND (Z, 3):UBOUND (Z, 3)))

DO ILEV2 = 1, NLEV2
  ZLEV2 = REAL (ILEV2 - 1) / REAL (NLEV2 -1)
  ZLEV1 = 1. + ZLEV2 * REAL (NLEV1 - 1)
  ILEV1B = MIN (CEILING (ZLEV1), NLEV1)
  ILEV1A = MAX (FLOOR   (ZLEV1),     1)

  IF (ILEV1A == ILEV1B) THEN
    ZWA = 1.
    ZWB = 0.
  ELSE
    ZWA = REAL (ILEV1B) - ZLEV1
    ZWB = ZLEV1 - REAL (ILEV1A)
  ENDIF

! WRITE (*, '(" ZLEV2 = ",E12.5," ZLEV1 = ",E12.5," ILEV2 = ",I4," ILEV1A = ",I4," ZWA = ",E12.5," ILEV1B = ",I4," ZWB = ",E12.5)') &
!   & ZLEV2, ZLEV1, ILEV2, ILEV1A, ZWA, ILEV1B, ZWB

  L (1:KOFF, ILEV2, :) = ZWA * MERGE(1., 0., Z (1:KOFF, ILEV1A, :)) + ZWB * MERGE(1., 0., Z (1:KOFF, ILEV1B, :)) >= 0.5
ENDDO

END SUBROUTINE


SUBROUTINE SETI2 (K)
IMPLICIT NONE

INTEGER, INTENT(OUT) :: K (:,:)
INTEGER :: IBL, IGPBLKS
INTEGER :: NTID, ITID, JBLK1, JBLK2


IGPBLKS = SIZE (K, 2)

!$OMP PARALLEL PRIVATE (ITID, JBLK1, JBLK2, NTID)
NTID = OMP_GET_MAX_THREADS ()
ITID = OMP_GET_THREAD_NUM ()
JBLK1 = 1 +  (IGPBLKS * (ITID+0)) / NTID
JBLK2 =      (IGPBLKS * (ITID+1)) / NTID

DO IBL = JBLK1, JBLK2
  K (:,IBL) = NINVALID
ENDDO

!$OMP END PARALLEL

END SUBROUTINE

SUBROUTINE SETR2 (P)
IMPLICIT NONE

REAL, INTENT(INOUT) :: P (:,:)
INTEGER :: IBL, IGPBLKS
INTEGER :: NTID, ITID, JBLK1, JBLK2


IGPBLKS = SIZE (P, 2)

!$OMP PARALLEL PRIVATE (ITID, JBLK1, JBLK2, NTID)
NTID = OMP_GET_MAX_THREADS ()
ITID = OMP_GET_THREAD_NUM ()
JBLK1 = 1 +  (IGPBLKS * (ITID+0)) / NTID
JBLK2 =      (IGPBLKS * (ITID+1)) / NTID

DO IBL = JBLK1, JBLK2
  P (:,IBL) = XINVALID
ENDDO

!$OMP END PARALLEL

END SUBROUTINE

SUBROUTINE SETR3 (P)
IMPLICIT NONE

REAL, INTENT(INOUT) :: P (:,:,:)
INTEGER :: IBL, IGPBLKS
INTEGER :: NTID, ITID, JBLK1, JBLK2

IGPBLKS = SIZE (P, 3)

!$OMP PARALLEL PRIVATE (ITID, JBLK1, JBLK2, NTID)
NTID = OMP_GET_MAX_THREADS ()
ITID = OMP_GET_THREAD_NUM ()
JBLK1 = 1 +  (IGPBLKS * (ITID+0)) / NTID
JBLK2 =      (IGPBLKS * (ITID+1)) / NTID

DO IBL = JBLK1, JBLK2
  P (:,:,IBL) = XINVALID
ENDDO

!$OMP END PARALLEL

END SUBROUTINE

SUBROUTINE SETR4 (P)
IMPLICIT NONE

REAL, INTENT(INOUT) :: P (:,:,:,:)
INTEGER :: IBL, IGPBLKS
INTEGER :: NTID, ITID, JBLK1, JBLK2

IGPBLKS = SIZE (P, 4)

!$OMP PARALLEL PRIVATE (ITID, JBLK1, JBLK2, NTID)
NTID = OMP_GET_MAX_THREADS ()
ITID = OMP_GET_THREAD_NUM ()
JBLK1 = 1 +  (IGPBLKS * (ITID+0)) / NTID
JBLK2 =      (IGPBLKS * (ITID+1)) / NTID

DO IBL = JBLK1, JBLK2
  P (:,:,:,IBL) = XINVALID
ENDDO

!$OMP END PARALLEL

END SUBROUTINE

END MODULE ARRAYS_MANIP
