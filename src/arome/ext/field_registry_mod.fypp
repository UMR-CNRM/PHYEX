#:set surface_config_file = os.path.dirname(_THIS_FILE_) + '/surface_fields_config.yaml'
#:set surface_config = field_config.VariableConfiguration(surface_config_file)
#:set surface_prognostic = [field_config.VariableGroup(**group) for group in surface_config.schema['prognostic']]
#:set surface_diagnostic = [field_config.VariableGroup(**group) for group in surface_config.schema['diagnostic']]
#:set surface_variable_groups = surface_prognostic + surface_diagnostic

#:set config_file = os.path.dirname(_THIS_FILE_) + '/field_config.yaml'


#:set config = field_config.VariableConfiguration(config_file)
#:set gfl = config.groups['GFL']
MODULE FIELD_REGISTRY_MOD

USE PARKIND1, ONLY : JPIM, JPRB, JPRD
USE FIELD_MODULE, ONLY: FIELD_2D, FIELD_INT2D, FIELD_LOG2D, FIELD_3D, FIELD_INT3D, FIELD_4D, FIELD_5D, &
 &                      FIELD_2D_EMPTY, FIELD_3D_EMPTY, FIELD_4D_EMPTY, ALLOCATE_FIELD
USE GEOMETRY_MOD, ONLY: GEOMETRY
USE VARIABLE_MODULE, ONLY: VARIABLE_2D, VARIABLE_3D, VARIABLE_4D, VARIABLE_3D_PTR
#ifdef PARKIND1_SINGLE
USE FIELD_MODULE, ONLY: FIELD_D2D, FIELD_D3D, FIELD_D4D, FIELD_D5D, &
 &                      FIELD_D2D_EMPTY, FIELD_D3D_EMPTY, FIELD_D4D_EMPTY
#endif
USE FIELD_MANAGEMENT_MOD
USE GEOMETRY_MOD, ONLY: GEOMETRY
USE VARIABLE_MODULE, ONLY: VARIABLE_2D, VARIABLE_3D, VARIABLE_4D
#ifdef PARKIND1_SINGLE
USE VARIABLE_MODULE, ONLY: VARIABLE_D2D, VARIABLE_D3D, VARIABLE_D4D
#endif
USE FIELD_VARIABLES_MOD, ONLY: FIELD_VARIABLES
USE SURFACE_VARIABLES_MOD, ONLY: SURFACE_VARIABLES
USE YOMGMV, ONLY: TGMV
USE YOM_YGFL, ONLY: TYPE_GFL_COMP, TYPE_GFLD
USE YOMGFL, ONLY: TGFL
USE SURFACE_FIELDS_MIX, ONLY: TSURF, TYPE_SURF_MTL_2D, TYPE_SURF_MTL_3D, TYPE_SURF_GEN
USE EC_PHYS_FIELDS_MOD, ONLY: TEC_PHYS_FIELDS
USE MODEL_PHYSICS_RADIATION_MOD, ONLY : MODEL_PHYSICS_RADIATION_TYPE

IMPLICIT NONE

TYPE :: FIELD_REGISTRY
  TYPE(GEOMETRY), POINTER :: GEOM => NULL()
  INTEGER(KIND=JPIM) :: NPROMA, NBLOCKS

CONTAINS
  PROCEDURE :: INIT => FIELD_REGISTRY_INIT
  PROCEDURE :: FINAL => FIELD_REGISTRY_FINAL

  PROCEDURE :: FIELD_REGISTRY_CREATE_VARIABLE_2D_GMV, FIELD_REGISTRY_CREATE_VARIABLE_3D_GMV
  PROCEDURE :: FIELD_REGISTRY_CREATE_VARIABLE_GFL, FIELD_REGISTRY_CREATE_VARIABLE_ARRAY_GFL

  PROCEDURE :: FIELD_REGISTRY_CREATE_VARIABLE_WRAP_2D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_2D
  PROCEDURE :: FIELD_REGISTRY_CREATE_VARIABLE_WRAP_3D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_3D
  PROCEDURE :: FIELD_REGISTRY_CREATE_VARIABLE_WRAP_4D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_4D

#ifdef PARKIND1_SINGLE
  PROCEDURE :: FIELD_REGISTRY_CREATE_VARIABLE_WRAP_D2D
#endif

  GENERIC   :: CREATE_VARIABLE => &
   & FIELD_REGISTRY_CREATE_VARIABLE_2D_GMV, FIELD_REGISTRY_CREATE_VARIABLE_3D_GMV, &
   & FIELD_REGISTRY_CREATE_VARIABLE_GFL, FIELD_REGISTRY_CREATE_VARIABLE_ARRAY_GFL, &
   & FIELD_REGISTRY_CREATE_VARIABLE_WRAP_2D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_2D, &
   & FIELD_REGISTRY_CREATE_VARIABLE_WRAP_3D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_3D, &
   & FIELD_REGISTRY_CREATE_VARIABLE_WRAP_4D, FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_4D

#ifdef PARKIND1_SINGLE
  GENERIC   :: CREATE_VARIABLE => &
   & FIELD_REGISTRY_CREATE_VARIABLE_WRAP_D2D
#endif

  PROCEDURE :: CREATE_SURFACE_VARIABLE_2D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_2D
  PROCEDURE :: CREATE_SURFACE_VARIABLE_ARRAY_2D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_2D
  PROCEDURE :: CREATE_SURFACE_VARIABLE_ARRAY2_2D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_2D
  PROCEDURE :: CREATE_SURFACE_VARIABLE_3D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_3D
  PROCEDURE :: CREATE_SURFACE_VARIABLE_ARRAY_3D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_3D
  PROCEDURE :: CREATE_SURFACE_VARIABLE_ARRAY2_3D => FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_3D
  PROCEDURE :: REGISTER_GEOMETRY => FIELD_REGISTRY_REGISTER_GEOMETRY
  PROCEDURE :: REGISTER_GMV_FIELDS => FIELD_REGISTRY_REGISTER_GMV_FIELDS
  PROCEDURE :: REGISTER_GFL_FIELDS => FIELD_REGISTRY_REGISTER_GFL_FIELDS
  PROCEDURE :: REGISTER_SURFACE_FIELDS => FIELD_REGISTRY_REGISTER_SURFACE_FIELDS
  PROCEDURE :: REGISTER_EC_PHYS_FIELDS => FIELD_REGISTRY_REGISTER_EC_PHYS_FIELDS
  PROCEDURE :: REGISTER_PHYSICS_RADIATION_FIELDS => FIELD_REGISTRY_REGISTER_PHYSICS_RADIATION_FIELDS

END TYPE FIELD_REGISTRY

ABSTRACT INTERFACE 
  LOGICAL FUNCTION FUN_GREP (YDVAR, YDCOMP, YDMODEL)
    USE VARIABLE_MODULE, ONLY : VARIABLE_3D
    USE YOM_YGFL, ONLY : TYPE_GFL_COMP
    USE TYPE_MODEL, ONLY : MODEL
    TYPE (VARIABLE_3D), INTENT (IN) :: YDVAR
    TYPE (TYPE_GFL_COMP), INTENT (IN) :: YDCOMP
    TYPE (MODEL),  INTENT (IN) :: YDMODEL
  END FUNCTION
END INTERFACE

PRIVATE :: FUN_GREP, GREPVARS_PTR

CONTAINS

  FUNCTION CREATE_FIELD_EMPTY_2D(SHAPE) RESULT(FIELD_PTR)
    ! Create an empty 2D field object with NULL data pointers
    TYPE(FIELD_2D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(1)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_2D_EMPTY(SHAPE=SHAPE)
  END FUNCTION CREATE_FIELD_EMPTY_2D

  FUNCTION CREATE_FIELD_EMPTY_3D(SHAPE) RESULT(FIELD_PTR)
    ! Create an empty 3D field object with NULL data pointers
    TYPE(FIELD_3D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(2)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_3D_EMPTY(SHAPE=SHAPE)
  END FUNCTION CREATE_FIELD_EMPTY_3D

  FUNCTION CREATE_FIELD_EMPTY_4D(SHAPE) RESULT(FIELD_PTR)
    ! Create an empty 4D field object with NULL data pointers
    TYPE(FIELD_4D), POINTER :: FIELD_PTR
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(3)

    ALLOCATE(FIELD_PTR)
    FIELD_PTR = FIELD_4D_EMPTY(SHAPE=SHAPE)
  END FUNCTION CREATE_FIELD_EMPTY_4D


  SUBROUTINE FIELD_REGISTRY_INIT(SELF, GEOM)
    ! Constructor for global field registry
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(GEOMETRY), TARGET, INTENT(IN) :: GEOM

    SELF%GEOM => GEOM
    SELF%NBLOCKS = GEOM%YRDIM%NGPBLKS
    SELF%NPROMA = GEOM%YRDIM%NPROMA
  END SUBROUTINE FIELD_REGISTRY_INIT

  SUBROUTINE FIELD_REGISTRY_FINAL(SELF)
    ! Finalize and tear down the global field registry
    CLASS(FIELD_REGISTRY) :: SELF
    INTEGER(KIND=JPIM) :: I

  END SUBROUTINE FIELD_REGISTRY_FINAL


  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_2D(SELF, NAME, DATA) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_2D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:)

    VARIABLE = VARIABLE_2D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_2D

#ifdef PARKIND1_SINGLE
  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_D2D(SELF, NAME, DATA) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_D2D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRD), TARGET, INTENT(IN) :: DATA(:,:)

    VARIABLE = VARIABLE_D2D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_D2D
#endif

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_3D(SELF, NAME, DATA) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_3D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:)

    VARIABLE = VARIABLE_3D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_3D

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_4D(SELF, NAME, DATA) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_4D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:)

    VARIABLE = VARIABLE_4D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_4D

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_2D(SELF, NAME, DATA, IDX) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_2D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX

    VARIABLE = VARIABLE_2D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA, IDX=IDX)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_2D

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_3D(SELF, NAME, DATA, IDX) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_3D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX

    VARIABLE = VARIABLE_3D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA, IDX=IDX)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_3D

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_4D(SELF, NAME, DATA, IDX) RESULT(VARIABLE)
    ! Create the VARIABLE and FIELD metadata type and associate it with existing data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_4D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: IDX

    VARIABLE = VARIABLE_4D(NAME, LACTIVE=.TRUE.)
    VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=DATA, IDX=IDX)
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_WRAP_PACKED_4D

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_2D_GMV(SELF, NAME, GMV, GMVT1, PT0, PT1, PT9, PPH9, PDL, PDM, &
   &                                             PDL9, PDM9, PERSISTENT) RESULT(VARIABLE)
    ! Create the VARIABLE metadata type and associate it with fields and data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_2D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: GMV(:,:,:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: GMVT1(:,:,:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: PT0, PT1, PT9, PPH9, PDL, PDM, PDL9, PDM9
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    LOGICAL :: LT0, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9

    LT0 = PRESENT_AND_ACTIVE(PT0)
    LT1 = PRESENT_AND_ACTIVE(PT1)
    LT9 = PRESENT_AND_ACTIVE(PT9)
    LPH9 = PRESENT_AND_ACTIVE(PPH9)
    LDL = PRESENT_AND_ACTIVE(PDL)
    LDM = PRESENT_AND_ACTIVE(PDM)
    LDL9 = PRESENT_AND_ACTIVE(PDL9)
    LDM9 = PRESENT_AND_ACTIVE(PDM9)
    VARIABLE = VARIABLE_2D(NAME, LACTIVE=.TRUE., LADV=.TRUE., LT1=LT1, LT9=LT9, LPH9=LPH9, LDL=LDL, LDM=LDM, &
                         & LDL9=LDL9, LDM9=LDM9)

    ! Associate FIELD objects with VARIABLE according to provided pointers
    IF (LT0) THEN
      VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PT0)
    ELSE
      VARIABLE%FT0 => NULL ()
    ENDIF
    IF (LT1) THEN
      VARIABLE%FT1 => CREATE_FIELD_WRAP(DATA=GMVT1(:,:,:), IDX=PT1)
    ELSE
      VARIABLE%FT1 => NULL()
    END IF
    IF (LT9) THEN
      VARIABLE%FT9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PT9)
    ELSE
      VARIABLE%FT9 => NULL()
    END IF
    IF (LPH9) THEN
      VARIABLE%FPH9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PPH9)
    ELSE
      VARIABLE%FPH9 => NULL()
    END IF
    IF (LDL) THEN
      VARIABLE%FDL => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PDL)
    ELSE
      VARIABLE%FDL => NULL()
    END IF
    IF (LDM) THEN
      VARIABLE%FDM => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PDM)
    ELSE
      VARIABLE%FDM => NULL()
    END IF
    IF (LDL9) THEN
      VARIABLE%FDL9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PDL9)
    ELSE
      VARIABLE%FDL9 => NULL()
    END IF
    IF (LDM9) THEN
      VARIABLE%FDM9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:), IDX=PDM9)
    ELSE
      VARIABLE%FDM9 => NULL()
    END IF

  CONTAINS

    FUNCTION PRESENT_AND_ACTIVE(PTR)
      INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: PTR
      LOGICAL PRESENT_AND_ACTIVE
      IF (PRESENT(PTR)) THEN
        PRESENT_AND_ACTIVE = PTR >= 0
      ELSE
        PRESENT_AND_ACTIVE = .FALSE.
      END IF
    END FUNCTION PRESENT_AND_ACTIVE
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_2D_GMV

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_3D_GMV(SELF, NAME, GMV, GMVT1, PT0, PT1, PT9, PPH9, PDL, PDM, &
   &                                             PDL9, PDM9, PERSISTENT) RESULT(VARIABLE)
    ! Create the VARIABLE metadata type and associate it with fields and data.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_3D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: GMV(:,:,:,:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: GMVT1(:,:,:,:)
    INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: PT0, PT1, PT9, PPH9, PDL, PDM, PDL9, PDM9
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    LOGICAL :: LT0, LT1, LT9, LPH9, LDL, LDM, LDL9, LDM9

    LT0 = PRESENT_AND_ACTIVE(PT0)
    LT1 = PRESENT_AND_ACTIVE(PT1)
    LT9 = PRESENT_AND_ACTIVE(PT9)
    LPH9 = PRESENT_AND_ACTIVE(PPH9)
    LDL = PRESENT_AND_ACTIVE(PDL)
    LDM = PRESENT_AND_ACTIVE(PDM)
    LDL9 = PRESENT_AND_ACTIVE(PDL9)
    LDM9 = PRESENT_AND_ACTIVE(PDM9)
    VARIABLE = VARIABLE_3D(NAME, LACTIVE=.TRUE., LADV=.TRUE., LT1=LT1, LT9=LT9, LPH9=LPH9, &
                         & LDL=LDL, LDM=LDM, LDL9=LDL9, LDM9=LDM9)

    ! Associate FIELD objects with VARIABLE according to provided pointers
    IF (LT0) THEN
      VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PT0)
    ELSE
      VARIABLE%FT0 => NULL ()
    ENDIF

    IF (LT1) THEN
      VARIABLE%FT1 => CREATE_FIELD_WRAP(DATA=GMVT1(:,:,:,:), IDX=PT1)
    ELSE
      VARIABLE%FT1 => NULL()
    END IF
    IF (LT9) THEN
      VARIABLE%FT9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PT9)
    ELSE
      VARIABLE%FT9 => NULL()
    END IF
    IF (LPH9) THEN
      VARIABLE%FPH9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PPH9)
    ELSE
      VARIABLE%FPH9 => NULL()
    END IF
    IF (LDL) THEN
      VARIABLE%FDL => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PDL)
   ELSE
      VARIABLE%FDL => NULL()
    END IF
    IF (LDM) THEN
      VARIABLE%FDM => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PDM)
    ELSE
      VARIABLE%FDM => NULL()
    END IF
    IF (LDL9) THEN
      VARIABLE%FDL9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PDL9)
    ELSE
      VARIABLE%FDL9 => NULL()
    END IF
    IF (LDM9) THEN
      VARIABLE%FDM9 => CREATE_FIELD_WRAP(DATA=GMV(:,:,:,:), IDX=PDM9)
    ELSE
      VARIABLE%FDM9 => NULL()
    END IF

  CONTAINS

    FUNCTION PRESENT_AND_ACTIVE(PTR)
      INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: PTR
      LOGICAL PRESENT_AND_ACTIVE
      IF (PRESENT(PTR)) THEN
        PRESENT_AND_ACTIVE = PTR >= 0
      ELSE
        PRESENT_AND_ACTIVE = .FALSE.
      END IF
    END FUNCTION PRESENT_AND_ACTIVE
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_3D_GMV

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_GFL(SELF, NAME, YDCOMP, GFL, PERSISTENT) RESULT(VARIABLE)
    ! Create a single field from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_3D) :: VARIABLE
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(TYPE_GFL_COMP), INTENT(IN) :: YDCOMP
    TYPE(TGFL), TARGET, INTENT(INOUT) :: GFL
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT

    VARIABLE = VARIABLE_3D(NAME, CNAME=YDCOMP%CNAME, IGRBCODE=YDCOMP%IGRBCODE, LACTIVE=YDCOMP%LACTIVE, &
     &                     LADV=YDCOMP%LADV, LT1=YDCOMP%LT1, LT9=YDCOMP%LT9, LPH9=YDCOMP%LPHY, LGP=YDCOMP%LGP, LWATER=YDCOMP%LWATER,&
     &                     LTHERMACT=YDCOMP%LTHERMACT,RCP=YDCOMP%RCP,R=YDCOMP%R,LCDERS=YDCOMP%LCDERS)

    VARIABLE%YCOMP = YDCOMP

    ! Associate FIELD objects with VARIABLE according to provided pointers
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MP > 0) THEN
      VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=GFL%GFL(:,:,:,:), IDX=YDCOMP%MP)
    ELSE
      VARIABLE%FT0 => NULL()
    END IF
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MP1 > 0) THEN
      VARIABLE%FT1 => CREATE_FIELD_WRAP(DATA=GFL%GFLT1(:,:,:,:), IDX=YDCOMP%MP1)
    ELSE
      VARIABLE%FT1 => NULL()
    END IF
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MP9 > 0) THEN
      VARIABLE%FT9 => CREATE_FIELD_WRAP(DATA=GFL%GFL(:,:,:,:), IDX=YDCOMP%MP9)
    ELSE
      VARIABLE%FT9 => NULL()
    END IF
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MP9_PH > 0) THEN
      VARIABLE%FPH9 => CREATE_FIELD_WRAP(DATA=GFL%GFL(:,:,:,:), IDX=YDCOMP%MP9_PH)
    ELSE
      VARIABLE%FPH9 => NULL()
    END IF
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MPL > 0) THEN
      VARIABLE%FDL => CREATE_FIELD_WRAP(DATA=GFL%GFL(:,:,:,:), IDX=YDCOMP%MPL)
    ELSE
      VARIABLE%FDL => NULL()
    END IF
    IF (YDCOMP%LACTIVE .AND. YDCOMP%MPM > 0) THEN
      VARIABLE%FDM => CREATE_FIELD_WRAP(DATA=GFL%GFL(:,:,:,:), IDX=YDCOMP%MPM)
    ELSE
      VARIABLE%FDM => NULL()
    END IF

  CONTAINS

    FUNCTION ACTIVE_AND_TRUE(LFLAG)
      LOGICAL ACTIVE_AND_TRUE
      LOGICAL, INTENT(IN) :: LFLAG
      IF (YDCOMP%LACTIVE) THEN
        ACTIVE_AND_TRUE = LFLAG
      ELSE
        ACTIVE_AND_TRUE = .FALSE.
      END IF
    END FUNCTION ACTIVE_AND_TRUE
  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_GFL

  FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_ARRAY_GFL(SELF, NAME, YDCOMP, GFL, PERSISTENT) RESULT(VARIABLES)
    ! Create a single field from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(VARIABLE_3D), ALLOCATABLE :: VARIABLES(:)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(TYPE_GFL_COMP), POINTER, INTENT(IN) :: YDCOMP(:)
    TYPE(TGFL), TARGET, INTENT(INOUT) :: GFL
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: I
    CHARACTER(:), ALLOCATABLE :: VNAME
    CHARACTER*8 :: CLI

    IF (ASSOCIATED(YDCOMP)) THEN
      ALLOCATE(VARIABLES(SIZE(YDCOMP)))
      DO I=1, SIZE(YDCOMP)
        WRITE (CLI, '(I0)') I
        VNAME = NAME//"_"//TRIM(CLI)
        VARIABLES(I) = SELF%CREATE_VARIABLE(VNAME, YDCOMP(I), GFL, PERSISTENT=PERSISTENT)
        VARIABLES(I)%YCOMP = YDCOMP (I)
      END DO
    ELSE
      ALLOCATE(VARIABLES(0))
    END IF

  END FUNCTION FIELD_REGISTRY_CREATE_VARIABLE_ARRAY_GFL

  SUBROUTINE FIELD_REGISTRY_REGISTER_GEOMETRY(SELF, VARIABLES, GEOM)
    ! Utility routine to register geometry fields in the current field container
    !
    ! Note that this is not meant to stay forever. It is required for gradual
    ! migration of existing arrays to an Atlas-based memory management system.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(FIELD_VARIABLES), POINTER, INTENT(INOUT) :: VARIABLES
    TYPE(GEOMETRY), INTENT(IN) :: GEOM

    IF (.NOT. ASSOCIATED(VARIABLES)) ALLOCATE(VARIABLES)

    VARIABLES%GEOMETRY%RCORI  = SELF%CREATE_VARIABLE(NAME='RCORI', DATA=GEOM%YRGSGEOM_B%RCORI)
    VARIABLES%GEOMETRY%RCORIC = SELF%CREATE_VARIABLE(NAME='RCORIC', DATA=GEOM%YRGSGEOM_B%RCORIC)
    VARIABLES%GEOMETRY%GEMU   = SELF%CREATE_VARIABLE(NAME='GEMU', DATA=GEOM%YRGSGEOM_B%GEMU)
    VARIABLES%GEOMETRY%GSQM2  = SELF%CREATE_VARIABLE(NAME='GSQM2', DATA=GEOM%YRGSGEOM_B%GSQM2)
    VARIABLES%GEOMETRY%GELAM  = SELF%CREATE_VARIABLE(NAME='GELAM', DATA=GEOM%YRGSGEOM_B%GELAM)
    VARIABLES%GEOMETRY%GELAT  = SELF%CREATE_VARIABLE(NAME='GELAT', DATA=GEOM%YRGSGEOM_B%GELAT)
    VARIABLES%GEOMETRY%GECLO  = SELF%CREATE_VARIABLE(NAME='GECLO', DATA=GEOM%YRGSGEOM_B%GECLO)
    VARIABLES%GEOMETRY%GESLO  = SELF%CREATE_VARIABLE(NAME='GESLO', DATA=GEOM%YRGSGEOM_B%GESLO)
    VARIABLES%GEOMETRY%GM     = SELF%CREATE_VARIABLE(NAME='GM', DATA=GEOM%YRGSGEOM_B%GM)
    VARIABLES%GEOMETRY%GMAPPA = SELF%CREATE_VARIABLE(NAME='GMAPPA', DATA=GEOM%YRGSGEOM_B%GMAPPA)
    VARIABLES%GEOMETRY%GOMVRL = SELF%CREATE_VARIABLE(NAME='GOMVRL', DATA=GEOM%YRGSGEOM_B%GOMVRL)
    VARIABLES%GEOMETRY%GOMVRM = SELF%CREATE_VARIABLE(NAME='GOMVRM', DATA=GEOM%YRGSGEOM_B%GOMVRM)
    VARIABLES%GEOMETRY%GNORDL = SELF%CREATE_VARIABLE(NAME='GNORDL', DATA=GEOM%YRGSGEOM_B%GNORDL)
    VARIABLES%GEOMETRY%GNORDM = SELF%CREATE_VARIABLE(NAME='GNORDM', DATA=GEOM%YRGSGEOM_B%GNORDM)
    VARIABLES%GEOMETRY%GNORDLCL = SELF%CREATE_VARIABLE(NAME='GNORDLCL', DATA=GEOM%YRGSGEOM_B%GNORDLCL)
    VARIABLES%GEOMETRY%GNORDMCL = SELF%CREATE_VARIABLE(NAME='GNORDMCL', DATA=GEOM%YRGSGEOM_B%GNORDMCL)
    VARIABLES%GEOMETRY%GNORDMCM = SELF%CREATE_VARIABLE(NAME='GNORDMCM', DATA=GEOM%YRGSGEOM_B%GNORDMCM)
    VARIABLES%GEOMETRY%GAW   = SELF%CREATE_VARIABLE(NAME='GAW', DATA=GEOM%YRGSGEOM_B%GAW)
    ! INTEGER(KIND=JPIM), POINTER,CONTIGUOUS :: NGPLAT(:,:)    => NULL()
    ! INTEGER(KIND=JPIM), POINTER,CONTIGUOUS :: NUNIQUEGP(:,:) => NULL()

    VARIABLES%GEOMETRY%OROG  = SELF%CREATE_VARIABLE(NAME='OROG', DATA=GEOM%YROROG_B%OROG)
    VARIABLES%GEOMETRY%OROGL = SELF%CREATE_VARIABLE(NAME='OROGL', DATA=GEOM%YROROG_B%OROGL)
    VARIABLES%GEOMETRY%OROGM = SELF%CREATE_VARIABLE(NAME='OROGM', DATA=GEOM%YROROG_B%OROGM)

    VARIABLES%GEOMETRY%OROGLL = SELF%CREATE_VARIABLE(NAME='OROGLL', DATA=GEOM%YROROG_B%OROGLL)
    VARIABLES%GEOMETRY%OROGMM = SELF%CREATE_VARIABLE(NAME='OROGMM', DATA=GEOM%YROROG_B%OROGMM)
    VARIABLES%GEOMETRY%OROGLM = SELF%CREATE_VARIABLE(NAME='OROGLM', DATA=GEOM%YROROG_B%OROGLM)

    VARIABLES%GEOMETRY%RCOLON = SELF%CREATE_VARIABLE (NAME='RCOLON', DATA=GEOM%YRCSGEOM_B%RCOLON)
    VARIABLES%GEOMETRY%RSILON = SELF%CREATE_VARIABLE (NAME='RSILON', DATA=GEOM%YRCSGEOM_B%RSILON)
    VARIABLES%GEOMETRY%RINDX  = SELF%CREATE_VARIABLE (NAME='RINDX' , DATA=GEOM%YRCSGEOM_B%RINDX )
    VARIABLES%GEOMETRY%RINDY  = SELF%CREATE_VARIABLE (NAME='RINDY' , DATA=GEOM%YRCSGEOM_B%RINDY )
    VARIABLES%GEOMETRY%RATATH = SELF%CREATE_VARIABLE (NAME='RATATH', DATA=GEOM%YRCSGEOM_B%RATATH)
    VARIABLES%GEOMETRY%RATATX = SELF%CREATE_VARIABLE (NAME='RATATX', DATA=GEOM%YRCSGEOM_B%RATATX)

    IF (ASSOCIATED (GEOM%YRGSGEOM_B%GEXCO)) VARIABLES%GEOMETRY%GEXCO = SELF%CREATE_VARIABLE (NAME='GEXCO', DATA=GEOM%YRGSGEOM_B%GEXCO)
    IF (ASSOCIATED (GEOM%YRGSGEOM_B%GEYCO)) VARIABLES%GEOMETRY%GEYCO = SELF%CREATE_VARIABLE (NAME='GEYCO', DATA=GEOM%YRGSGEOM_B%GEYCO)
    IF (ASSOCIATED (GEOM%YRGSGEOM_B%GEZCO)) VARIABLES%GEOMETRY%GEZCO = SELF%CREATE_VARIABLE (NAME='GEZCO', DATA=GEOM%YRGSGEOM_B%GEZCO)

  END SUBROUTINE FIELD_REGISTRY_REGISTER_GEOMETRY

  SUBROUTINE FIELD_REGISTRY_REGISTER_GMV_FIELDS(SELF, VARIABLES, GMV)
    ! Utility routine to register GMV fields with the global field registry
    !
    ! Note that this is not meant to stay forever. It is required for gradual
    ! migration of existing arrays to the new object-based data management system.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(FIELD_VARIABLES), POINTER, INTENT(INOUT) :: VARIABLES
    TYPE(TGMV), INTENT(INOUT) :: GMV  ! Allocated arrays and pointers

    IF (.NOT. ASSOCIATED(VARIABLES)) ALLOCATE(VARIABLES)

    ASSOCIATE(GMVT1=>GMV%GMVT1, GMVS=>GMV%GMVS, GMVT1S=>GMV%GMVT1S, &
     &        YT0=>GMV%YT0, YT1=>GMV%YT1, YT9=>GMV%YT9, YPH9=>GMV%YPH9)
    VARIABLES%U = SELF%CREATE_VARIABLE('U', GMV%GMV, GMVT1, PT0=YT0%MU, PT1=YT1%MU, PT9=YT9%MU, PPH9=YPH9%MU, PDL=YT0%MUL, PDL9=YT9%MUL)
    VARIABLES%V = SELF%CREATE_VARIABLE('V', GMV%GMV, GMVT1, PT0=YT0%MV, PT1=YT1%MV, PT9=YT9%MV, PPH9=YPH9%MV, PDL=YT0%MVL, PDL9=YT9%MVL)
    VARIABLES%T = SELF%CREATE_VARIABLE('T', GMV%GMV, GMVT1, PT0=YT0%MT, PT1=YT1%MT, PT9=YT9%MT, PPH9=YPH9%MT, PDL=YT0%MTL, PDM=YT0%MTM, PDL9=YT9%MTL, PDM9=YT9%MTM)
    VARIABLES%DIV = SELF%CREATE_VARIABLE('DIV', GMV%GMV, GMVT1, PT0=YT0%MDIV, PT1=YT1%MDIV, PT9=YT9%MDIV)
    VARIABLES%VOR = SELF%CREATE_VARIABLE('VOR', GMV%GMV, GMVT1, PT0=YT0%MVOR, PT1=YT1%MVOR, PT9=YT9%MVOR)
    VARIABLES%SPD = SELF%CREATE_VARIABLE('SPD', GMV%GMV, GMVT1, PT0=YT0%MSPD, PT1=YT1%MSPD, PT9=YT9%MSPD, PDL=YT0%MSPDL, PDM=YT0%MSPDM, PDL9=YT9%MSPDL, PDM9=YT9%MSPDM)
    VARIABLES%SVD = SELF%CREATE_VARIABLE('SVD', GMV%GMV, GMVT1, PT0=YT0%MSVD, PT1=YT1%MSVD, PT9=YT9%MSVD, PDL=YT0%MSVDL, PDM=YT0%MSVDM, PDL9=YT9%MSVDL, PDM9=YT9%MSVDM)
    
    VARIABLES%CSPDNL = SELF%CREATE_VARIABLE('CSPDNL', GMV%GMV, GMVT1, PT9=YT9%MCSPDNL)
    VARIABLES%CSVDPT = SELF%CREATE_VARIABLE('CSVDPT', GMV%GMV, GMVT1, PT9=YT9%MCSVDPT)
    VARIABLES%CSPNL  = SELF%CREATE_VARIABLE('CSPNL' , GMV%GMV, GMVT1, PT9=YT9%MCSPNL)
    VARIABLES%CTNL   = SELF%CREATE_VARIABLE('CTNL'  , GMV%GMV, GMVT1, PT9=YT9%MCTNL)
    VARIABLES%CTPT   = SELF%CREATE_VARIABLE('CTPT'  , GMV%GMV, GMVT1, PT9=YT9%MCTPT)
    VARIABLES%CUNL   = SELF%CREATE_VARIABLE('CUNL'  , GMV%GMV, GMVT1, PT9=YT9%MCUNL)
    VARIABLES%CUPT   = SELF%CREATE_VARIABLE('CUPT'  , GMV%GMV, GMVT1, PT9=YT9%MCUPT)
    VARIABLES%CVNL   = SELF%CREATE_VARIABLE('CVNL'  , GMV%GMV, GMVT1, PT9=YT9%MCVNL)
    VARIABLES%CVPT   = SELF%CREATE_VARIABLE('CVPT'  , GMV%GMV, GMVT1, PT9=YT9%MCVPT)
    VARIABLES%CVWVNL = SELF%CREATE_VARIABLE('CVWVNL', GMV%GMV, GMVT1, PT9=YT9%MCVWVNL)
    VARIABLES%DPHI   = SELF%CREATE_VARIABLE('DPHI'  , GMV%GMV, GMVT1, PT9=YT9%MDPHI)

    VARIABLES%EDOT = SELF%CREATE_VARIABLE('EDOT', GMV%GMV, GMVT1, PT0=YT0%MEDOT, PT9=YT9%MEDOT)

    VARIABLES%GW     = SELF%CREATE_VARIABLE('GW'  , GMV%GMV, GMVT1, PT9=YT9%MGW)

    VARIABLES%NHX = SELF%CREATE_VARIABLE('NHX', GMV%GMV, GMVT1, PT0=YT0%MNHX, PT1=YT1%MNHX, PT9=YT9%MNHX, &
     &                                   PDL=YT0%MNHXL, PDM=YT0%MNHXM)

    VARIABLES%NHY    = SELF%CREATE_VARIABLE('NHY'  , GMV%GMV, GMVT1, PT9=YT9%MNHY)

    VARIABLES%SGRTL = SELF%CREATE_VARIABLE('SGRTL', GMV%GMV, GMVT1, PT0=YT0%MSGRTL, PT9=YT9%MSGRTL)
    VARIABLES%SGRTM = SELF%CREATE_VARIABLE('SGRTM', GMV%GMV, GMVT1, PT0=YT0%MSGRTM, PT9=YT9%MSGRTM)

    VARIABLES%SPDNL      = SELF%CREATE_VARIABLE('SPDNL'    , GMV%GMV, GMVT1, PT9=YT9%MSPDNL    )
    VARIABLES%SPDNL_SI   = SELF%CREATE_VARIABLE('SPDNL_SI' , GMV%GMV, GMVT1, PT9=YT9%MSPDNL_SI )
    VARIABLES%SPNL       = SELF%CREATE_VARIABLE('SPNL'     , GMV%GMV, GMVT1, PT9=YT9%MSPNL     )
    VARIABLES%SPNL_SI    = SELF%CREATE_VARIABLE('SPNL_SI'  , GMV%GMV, GMVT1, PT9=YT9%MSPNL_SI  )
    VARIABLES%SVDNL_SI   = SELF%CREATE_VARIABLE('SVDNL_SI' , GMV%GMV, GMVT1, PT9=YT9%MSVDNL_SI )
    VARIABLES%TNL        = SELF%CREATE_VARIABLE('TNL'      , GMV%GMV, GMVT1, PT9=YT9%MTNL      )
    VARIABLES%TNL_SI     = SELF%CREATE_VARIABLE('TNL_SI'   , GMV%GMV, GMVT1, PT9=YT9%MTNL_SI   )
    VARIABLES%UNL        = SELF%CREATE_VARIABLE('UNL'      , GMV%GMV, GMVT1, PT9=YT9%MUNL      )
    VARIABLES%UNL_SI     = SELF%CREATE_VARIABLE('UNL_SI'   , GMV%GMV, GMVT1, PT9=YT9%MUNL_SI   )
    VARIABLES%VNL        = SELF%CREATE_VARIABLE('VNL'      , GMV%GMV, GMVT1, PT9=YT9%MVNL      )
    VARIABLES%VNL_SI     = SELF%CREATE_VARIABLE('VNL_SI'   , GMV%GMV, GMVT1, PT9=YT9%MVNL_SI   )
    VARIABLES%VWVNL      = SELF%CREATE_VARIABLE('VWVNL'    , GMV%GMV, GMVT1, PT9=YT9%MVWVNL    )
    VARIABLES%CURHS      = SELF%CREATE_VARIABLE('CURHS'    , GMV%GMV, GMVT1, PT9=YT9%MCURHS     )
    VARIABLES%CVRHS      = SELF%CREATE_VARIABLE('CVRHS'    , GMV%GMV, GMVT1, PT9=YT9%MCVRHS     )
    VARIABLES%CTRHS      = SELF%CREATE_VARIABLE('CTRHS'    , GMV%GMV, GMVT1, PT9=YT9%MCTRHS     )
    VARIABLES%CSPDRHS    = SELF%CREATE_VARIABLE('CSPDRHS'  , GMV%GMV, GMVT1, PT9=YT9%MCSPDRHS   )
    VARIABLES%CSVDRHS    = SELF%CREATE_VARIABLE('CSVDRHS'  , GMV%GMV, GMVT1, PT9=YT9%MCSVDRHS   )
    VARIABLES%NHXNL      = SELF%CREATE_VARIABLE('NHXNL'  , GMV%GMV, GMVT1, PT9=YT9%MNHXNL   )
    VARIABLES%CNHXNL     = SELF%CREATE_VARIABLE('CNHXNL'  , GMV%GMV, GMVT1, PT9=YT9%MCNHXNL   )

    ! Field   pointers in GMVS
    VARIABLES%SP  = SELF%CREATE_VARIABLE('SP', GMVS, GMVT1S, PT0=YT0%MSP, PT1=YT1%MSP, PT9=YT9%MSP, &
     &                                   PPH9=YPH9%MSP, PDL=YT0%MSPL, PDM=YT0%MSPM, PDL9=YT9%MSPL, PDM9=YT9%MSPM)

    VARIABLES%SPNL2    = SELF%CREATE_VARIABLE('SPNL2'    ,  GMVS, GMVT1S, PT9=YT9%MSPNL2  )
    VARIABLES%PREHYDS  = SELF%CREATE_VARIABLE('PREHYDS'  ,  GMVS, GMVT1S, PT9=YT9%MPREHYDS)
    VARIABLES%DBBC     = SELF%CREATE_VARIABLE('DBBC'     ,  GMVS, GMVT1S, PT9=YT9%MDBBC   )
    VARIABLES%CSPPT    = SELF%CREATE_VARIABLE('CSPPT'    ,  GMVS, GMVT1S, PT9=YT9%MCSPPT  )
    VARIABLES%CSPNL2   = SELF%CREATE_VARIABLE('CSPNL2'   ,  GMVS, GMVT1S, PT9=YT9%MCSPNL2 )
    VARIABLES%CSPRHS   = SELF%CREATE_VARIABLE('CSPRHS'   ,  GMVS, GMVT1S, PT9=YT9%MCSPRHS )
    VARIABLES%GWS      = SELF%CREATE_VARIABLE('GWS'      ,  GMVS, GMVT1S, PT9=YT9%MGWS    )


    END ASSOCIATE

  END SUBROUTINE FIELD_REGISTRY_REGISTER_GMV_FIELDS

  SUBROUTINE FIELD_REGISTRY_REGISTER_GFL_FIELDS(SELF, VARIABLES, GFL_ARRAY, GFL_META, YDMODEL)
    USE TYPE_MODEL, ONLY : MODEL
    ! Utility routine to register GFL fields with the global field registry
    !
    ! Note that this is not meant to stay forever. It is required for gradual
    ! migration of existing arrays to an Atlas-based memory management system.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(FIELD_VARIABLES), POINTER, INTENT(INOUT) :: VARIABLES
    TYPE(TGFL), INTENT(INOUT) :: GFL_ARRAY  ! Actual allcoated arrays
    TYPE(TYPE_GFLD), INTENT(INOUT) :: GFL_META   ! Array of component metadata
    TYPE (MODEL), INTENT(IN) :: YDMODEL

    IF (.NOT. ASSOCIATED(VARIABLES)) ALLOCATE(VARIABLES)

#:for v in gfl.variables
#:if v.array == 1
    VARIABLES%${v.name}$_G = SELF%CREATE_VARIABLE('${v.name}$', GFL_META%Y${v.name}$, GFL_ARRAY)
    VARIABLES%${v.name}$ => VARIABLES%${v.name}$_G
#:else
    VARIABLES%${v.name}$ = SELF%CREATE_VARIABLE('${v.name}$', GFL_META%Y${v.name}$, GFL_ARRAY)
#:endif
#:endfor

    CALL GREPVARS_PTR (VARIABLES, YDMODEL, COND, VARIABLES%GFL_PTR_G)

  CONTAINS

    LOGICAL FUNCTION COND (YDVAR, YDCOMP, YDMODEL)
      USE YOM_YGFL, ONLY : TYPE_GFL_COMP
      TYPE (VARIABLE_3D), INTENT (IN) :: YDVAR
      TYPE (TYPE_GFL_COMP), INTENT (IN) :: YDCOMP
      TYPE (MODEL), INTENT(IN) :: YDMODEL
      COND = .TRUE.
    END FUNCTION

  END SUBROUTINE FIELD_REGISTRY_REGISTER_GFL_FIELDS

  SUBROUTINE FIELD_REGISTRY_REGISTER_EC_PHYS_FIELDS(SELF, VARIABLES, FIELDS)
    ! Utility routine to register EC physics fields in the current field container
    !
    ! Note that this is not meant to stay forever. It is required for gradual
    ! migration of existing arrays to an Atlas-based memory management system.
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(FIELD_VARIABLES), INTENT(INOUT) :: VARIABLES
    TYPE(TEC_PHYS_FIELDS), INTENT(INOUT) :: FIELDS

    VARIABLES%ECPHYS%USTRTI = SELF%CREATE_VARIABLE(NAME='USTRTI', DATA=FIELDS%YRTILEPROP%RUSTRTI) ! E-W  SURFACE STRESS
    VARIABLES%ECPHYS%VSTRTI = SELF%CREATE_VARIABLE(NAME='VSTRTI', DATA=FIELDS%YRTILEPROP%RVSTRTI) ! N-S  SURFACE STRESS
    VARIABLES%ECPHYS%AHFSTI = SELF%CREATE_VARIABLE(NAME='AHFSTI', DATA=FIELDS%YRTILEPROP%RAHFSTI) ! SURFACE SENSIBLE HEAT FLUX
    VARIABLES%ECPHYS%EVAPTI = SELF%CREATE_VARIABLE(NAME='EVAPTI', DATA=FIELDS%YRTILEPROP%REVAPTI) ! EVAPORATION
    VARIABLES%ECPHYS%TSKTI  = SELF%CREATE_VARIABLE(NAME='TSKTI',  DATA=FIELDS%YRTILEPROP%RTSKTI)  ! SKIN TEMPERATURE
  END SUBROUTINE FIELD_REGISTRY_REGISTER_EC_PHYS_FIELDS

  SUBROUTINE FIELD_REGISTRY_REGISTER_PHYSICS_RADIATION_FIELDS(SELF, VARIABLES, PHYS_RADI)
    ! Utility routine to register EC physics fields in the current field container
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(FIELD_VARIABLES), INTENT(INOUT) :: VARIABLES
    TYPE(MODEL_PHYSICS_RADIATION_TYPE), TARGET, INTENT(IN) :: PHYS_RADI

    VARIABLES%RADIATION%EMTD     = SELF%CREATE_VARIABLE(NAME='EMTD', DATA=PHYS_RADI%YRRADF%EMTD)
    VARIABLES%RADIATION%TRSW     = SELF%CREATE_VARIABLE(NAME='TRSW', DATA=PHYS_RADI%YRRADF%TRSW)
    VARIABLES%RADIATION%EMTC     = SELF%CREATE_VARIABLE(NAME='EMTC', DATA=PHYS_RADI%YRRADF%EMTC)
    VARIABLES%RADIATION%TRSC     = SELF%CREATE_VARIABLE(NAME='TRSC', DATA=PHYS_RADI%YRRADF%TRSC)
    VARIABLES%RADIATION%EMTU     = SELF%CREATE_VARIABLE(NAME='EMTU', DATA=PHYS_RADI%YRRADF%EMTU)
    VARIABLES%RADIATION%TAUAER   = SELF%CREATE_VARIABLE(NAME='TAUAER', DATA=PHYS_RADI%YRRADF%TAUAER)
    VARIABLES%RADIATION%SRSWD    = SELF%CREATE_VARIABLE(NAME='SRSWD', DATA=PHYS_RADI%YRRADF%SRSWD)
    VARIABLES%RADIATION%SRLWDC   = SELF%CREATE_VARIABLE(NAME='SRLWDC', DATA=PHYS_RADI%YRRADF%SRLWDC)
    VARIABLES%RADIATION%SRLWD    = SELF%CREATE_VARIABLE(NAME='SRLWD', DATA=PHYS_RADI%YRRADF%SRLWD)
    VARIABLES%RADIATION%SRSWDC   = SELF%CREATE_VARIABLE(NAME='SRSWDC', DATA=PHYS_RADI%YRRADF%SRSWDC)
    VARIABLES%RADIATION%SRSWDCS  = SELF%CREATE_VARIABLE(NAME='SRSWDCS', DATA=PHYS_RADI%YRRADF%SRSWDCS)
    VARIABLES%RADIATION%SRLWDCS  = SELF%CREATE_VARIABLE(NAME='SRLWDCS', DATA=PHYS_RADI%YRRADF%SRLWDCS)
    VARIABLES%RADIATION%SRSWDV   = SELF%CREATE_VARIABLE(NAME='SRSWDV', DATA=PHYS_RADI%YRRADF%SRSWDV)
    VARIABLES%RADIATION%SRSWDUV  = SELF%CREATE_VARIABLE(NAME='SRSWDUV', DATA=PHYS_RADI%YRRADF%SRSWDUV)
    VARIABLES%RADIATION%EDRO     = SELF%CREATE_VARIABLE(NAME='EDRO', DATA=PHYS_RADI%YRRADF%EDRO)
    VARIABLES%RADIATION%SRSWPAR  = SELF%CREATE_VARIABLE(NAME='SRSWPAR', DATA=PHYS_RADI%YRRADF%SRSWPAR)
    VARIABLES%RADIATION%SRSWUVB  = SELF%CREATE_VARIABLE(NAME='SRSWUVB', DATA=PHYS_RADI%YRRADF%SRSWUVB)
    VARIABLES%RADIATION%SRSWPARC = SELF%CREATE_VARIABLE(NAME='SRSWPARC', DATA=PHYS_RADI%YRRADF%SRSWPARC)
    VARIABLES%RADIATION%SRSWTINC = SELF%CREATE_VARIABLE(NAME='SRSWTINC', DATA=PHYS_RADI%YRRADF%SRSWTINC)
    VARIABLES%RADIATION%SRFDIR   = SELF%CREATE_VARIABLE(NAME='SRFDIR', DATA=PHYS_RADI%YRRADF%SRFDIR)
    VARIABLES%RADIATION%SRCDIR   = SELF%CREATE_VARIABLE(NAME='SRCDIR', DATA=PHYS_RADI%YRRADF%SRCDIR)
    VARIABLES%RADIATION%RMOON    = SELF%CREATE_VARIABLE(NAME='RMOON', DATA=PHYS_RADI%YRRADF%RMOON)
    VARIABLES%RADIATION%DERIVATIVELW = SELF%CREATE_VARIABLE(NAME='DERIVATIVELW', DATA=PHYS_RADI%YRRADF%DERIVATIVELW)
  END SUBROUTINE FIELD_REGISTRY_REGISTER_PHYSICS_RADIATION_FIELDS


  SUBROUTINE GREPVARS_PTR (VARIABLES, YDMODEL, COND, YDVARS_LIST)
    USE TYPE_MODEL, ONLY : MODEL
    TYPE(FIELD_VARIABLES), INTENT(INOUT), TARGET :: VARIABLES
    TYPE(MODEL), INTENT(IN) :: YDMODEL
    PROCEDURE (FUN_GREP) :: COND
    TYPE(VARIABLE_3D_PTR), ALLOCATABLE :: YDVARS_LIST (:)

    INTEGER (KIND=JPIM) :: ISIZE, JFLD, IPNTR
 
    ISIZE = 0

#:for v in gfl.variables
#:if v.array == 1
    IF (ASSOCIATED (VARIABLES%${v.name}$)) THEN
      DO JFLD = 1, SIZE (VARIABLES%${v.name}$)
        IF (COND (VARIABLES%${v.name}$(JFLD), YDMODEL%YRML_GCONF%YGFL%Y${v.name}$(JFLD), YDMODEL)) ISIZE = ISIZE + 1
      ENDDO
    ENDIF
#:else
    IF (COND (VARIABLES%${v.name}$, YDMODEL%YRML_GCONF%YGFL%Y${v.name}$, YDMODEL)) ISIZE = ISIZE + 1
#:endif
#:endfor

   ALLOCATE (YDVARS_LIST (ISIZE))

   IPNTR = 1

#:for v in gfl.variables
#:if v.array == 1
    IF (ASSOCIATED (VARIABLES%${v.name}$)) THEN
      DO JFLD = 1, SIZE (VARIABLES%${v.name}$)
        IF (COND (VARIABLES%${v.name}$(JFLD), YDMODEL%YRML_GCONF%YGFL%Y${v.name}$(JFLD), YDMODEL)) THEN
          YDVARS_LIST (IPNTR)%YV => VARIABLES%${v.name}$(JFLD)
          YDVARS_LIST (IPNTR)%YCOMP = VARIABLES%${v.name}$(JFLD)%YCOMP
          IPNTR = IPNTR + 1
        ENDIF
      ENDDO
    ENDIF
#:else
    IF (COND (VARIABLES%${v.name}$, YDMODEL%YRML_GCONF%YGFL%Y${v.name}$, YDMODEL)) THEN
      YDVARS_LIST (IPNTR)%YV => VARIABLES%${v.name}$
      YDVARS_LIST (IPNTR)%YCOMP = VARIABLES%${v.name}$%YCOMP
      IPNTR = IPNTR + 1
    ENDIF
#:endif
#:endfor
    

  END SUBROUTINE


  !----   Utility wrapper routines for surface variables   ----!

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_2D(SELF, NAME, VARIABLE, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create a single field from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_2D), INTENT(INOUT) :: VARIABLE
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:)
    TYPE(TYPE_SURF_MTL_2D), INTENT(IN) :: META
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT

    IF (.NOT. ACTIVE) THEN
      ! For inactive variables we still create full-sized temporaries,
      ! since the SURF module expects full NPROMA-sized buffers.
      VARIABLE = VARIABLE_2D(NAME, LACTIVE=.FALSE., LT1=.FALSE., LT9=.FALSE.)
      VARIABLE%FT0 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
      VARIABLE%FT1 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
      VARIABLE%FT9 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
    ELSE
      ! Create variable according to existing meta-data
      VARIABLE = VARIABLE_2D(NAME, LACTIVE=META%MP > 0, LT1=META%MP1 > 0, LT9=META%MP9 > 0)

      IF (META%MP > 0) THEN
        VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:), IDX=META%MP)
      ELSE
        VARIABLE%FT0 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
      END IF
      IF (META%MP1 > 0) THEN
        VARIABLE%FT1 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:), IDX=META%MP1)
      ELSE
        VARIABLE%FT1 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
      END IF
      IF (META%MP9 > 0) THEN
        VARIABLE%FT9 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:), IDX=META%MP9)
      ELSE
        VARIABLE%FT9 => CREATE_TEMPORARY(GEOM=SELF%GEOM, PERSISTENT=PERSISTENT)
      END IF
    END IF

  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_2D

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_2D(SELF, NAME, VARIABLES, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create an array of fields from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_2D), ALLOCATABLE, INTENT(INOUT) :: VARIABLES(:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:)
    TYPE(TYPE_SURF_MTL_2D), INTENT(IN) :: META(:)
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: I
    CHARACTER(:), ALLOCATABLE :: VNAME

    ALLOCATE(VARIABLES(SIZE(META)))
    DO I=1, SIZE(META)
      VNAME = NAME//"_"//CHAR(I)
      CALL SELF%CREATE_SURFACE_VARIABLE_2D(VNAME, VARIABLES(I), ARRAY, META(I), DESCR, ACTIVE, PERSISTENT)
    END DO
  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_2D

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_2D(SELF, NAME, VARIABLES, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create an array of fields from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_2D), ALLOCATABLE, INTENT(INOUT) :: VARIABLES(:,:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:)
    TYPE(TYPE_SURF_MTL_2D), INTENT(IN) :: META(:,:)
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: I, J
    CHARACTER(:), ALLOCATABLE :: VNAME

    ALLOCATE(VARIABLES(SIZE(META, DIM=1), SIZE(META, DIM=2)))
    DO J=1, SIZE(META, DIM=2)
      DO I=1, SIZE(META, DIM=1)
        VNAME = NAME//"_"//CHAR(I)//"_"//CHAR(J)
        CALL SELF%CREATE_SURFACE_VARIABLE_2D(VNAME, VARIABLES(I,J), ARRAY, META(I,J), DESCR, ACTIVE, PERSISTENT)
      END DO
    END DO
  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_2D

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_3D(SELF, NAME, VARIABLE, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create a single field from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_3D), INTENT(INOUT) :: VARIABLE
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:,:)
    TYPE(TYPE_SURF_MTL_3D), INTENT(IN) :: META
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT

    IF (.NOT. ACTIVE) THEN
      ! For inactive variables we still create full-sized temporaries,
      ! since the SURF module expects full NPROMA-sized buffers.
      VARIABLE = VARIABLE_3D(NAME, LACTIVE=.FALSE., LT1=.FALSE., LT9=.FALSE.)
      VARIABLE%FT0 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
      VARIABLE%FT1 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
      VARIABLE%FT9 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
    ELSE
      ! Create variable according to existing meta-data
      VARIABLE = VARIABLE_3D(NAME, LACTIVE=META%MP > 0, LT1=META%MP1 > 0, LT9=META%MP9 > 0)

      IF (META%MP > 0) THEN
        VARIABLE%FT0 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:,:), IDX=META%MP)
      ELSE
        VARIABLE%FT0 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
      END IF
      IF (META%MP1 > 0) THEN
        VARIABLE%FT1 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:,:), IDX=META%MP1)
      ELSE
        VARIABLE%FT1 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
      END IF
      IF (META%MP9 > 0) THEN
        VARIABLE%FT9 => CREATE_FIELD_WRAP(DATA=ARRAY(:,:,:,:), IDX=META%MP9)
      ELSE
        VARIABLE%FT9 => CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=DESCR%NLEVS, PERSISTENT=PERSISTENT)
      END IF
    END IF

  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_3D

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_3D(SELF, NAME, VARIABLES, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create an array of fields from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_3D), ALLOCATABLE, INTENT(INOUT) :: VARIABLES(:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:,:)
    TYPE(TYPE_SURF_MTL_3D), INTENT(IN) :: META(:)
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: I
    CHARACTER(:), ALLOCATABLE :: VNAME

    ALLOCATE(VARIABLES(SIZE(META)))
    DO I=1, SIZE(META)
      VNAME = NAME//"_"//CHAR(I)
      CALL SELF%CREATE_SURFACE_VARIABLE_3D(VNAME, VARIABLES(I), ARRAY, META(I), DESCR, ACTIVE, PERSISTENT)
    END DO
  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY_3D

  SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_3D(SELF, NAME, VARIABLES, ARRAY, META, DESCR, ACTIVE, PERSISTENT)
    ! Create an array of fields from a set of defaults and internalized field options
    CLASS(FIELD_REGISTRY) :: SELF
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    TYPE(VARIABLE_3D), ALLOCATABLE, INTENT(INOUT) :: VARIABLES(:,:)
    REAL(KIND=JPRB), TARGET, INTENT(IN) :: ARRAY(:,:,:,:)
    TYPE(TYPE_SURF_MTL_3D), INTENT(IN) :: META(:,:)
    TYPE(TYPE_SURF_GEN), INTENT(IN) :: DESCR
    LOGICAL, INTENT(IN) :: ACTIVE
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT
    INTEGER(KIND=JPIM) :: I, J
    CHARACTER(:), ALLOCATABLE :: VNAME

    ALLOCATE(VARIABLES(SIZE(META, DIM=1), SIZE(META, DIM=2)))
    DO J=1, SIZE(META, DIM=2)
      DO I=1, SIZE(META, DIM=1)
        VNAME = NAME//"_"//CHAR(I)//"_"//CHAR(J)
        CALL SELF%CREATE_SURFACE_VARIABLE_3D(VNAME, VARIABLES(I,J), ARRAY, META(I,J), DESCR, ACTIVE, PERSISTENT)
      END DO
    END DO
  END SUBROUTINE FIELD_REGISTRY_CREATE_SURFACE_VARIABLE_ARRAY2_3D

  SUBROUTINE FIELD_REGISTRY_REGISTER_SURFACE_FIELDS(SELF, SURFVARS, YDSURF, PERSISTENT)
    ! Register all surface variables detailed in the configuration file
    CLASS(FIELD_REGISTRY) :: SELF
    TYPE(SURFACE_VARIABLES), POINTER, INTENT(INOUT) :: SURFVARS
    TYPE(TSURF), TARGET, INTENT(INOUT) :: YDSURF
    LOGICAL, OPTIONAL, INTENT(IN) :: PERSISTENT

    IF (.NOT. ASSOCIATED(SURFVARS)) ALLOCATE(SURFVARS)

#:for group in surface_prognostic
    ASSOCIATE(SP_${group.short}$=>YDSURF%SP_${group.short}$, YSP_${group.short}$=>YDSURF%YSP_${group.short}$, YSP_${group.short}$D=>YDSURF%YSP_${group.short}$D)
#:for v in group.variables
#:if v.array == 1
    IF (ASSOCIATED(YSP_${group.short}$%Y${v.name}$)) THEN
      CALL SELF%CREATE_SURFACE_VARIABLE_ARRAY_${group.dimension}$D(NAME='SP_${group.short}$_${v.name}$', &
       & VARIABLES=SURFVARS%GSP_${group.short}$%V${v.name}$, ARRAY=SP_${group.short}$, &
       & META=YSP_${group.short}$%Y${v.name}$(:), DESCR=YSP_${group.short}$D, &
       & ACTIVE=ASSOCIATED(YSP_${group.short}$%Y${v.name}$))
    END IF
#:elif v.array == 2
    IF (ASSOCIATED(YSP_${group.short}$%Y${v.name}$)) THEN
      CALL SELF%CREATE_SURFACE_VARIABLE_ARRAY_${group.dimension}$D(NAME='SP_${group.short}$_${v.name}$', &
       & VARIABLES=SURFVARS%GSP_${group.short}$%V${v.name}$, ARRAY=SP_${group.short}$, &
       & META=YSP_${group.short}$%Y${v.name}$(:,:), DESCR=YSP_${group.short}$D, &
       & ACTIVE=ASSOCIATED(YSP_${group.short}$%Y${v.name}$))
    END IF
#:else
    CALL SELF%CREATE_SURFACE_VARIABLE_${group.dimension}$D(NAME='SP_${group.short}$_${v.name}$', &
     & VARIABLE=SURFVARS%GSP_${group.short}$%V${v.name}$, ARRAY=SP_${group.short}$, &
     & META=YSP_${group.short}$%Y${v.name}$, DESCR=YSP_${group.short}$D, &
     & ACTIVE=ASSOCIATED(YSP_${group.short}$%Y${v.name}$))
#:endif
#:endfor

    IF (YSP_${group.short}$D%NDIM == 0) THEN
#:if group.dimension == 2
      SURFVARS%GSP_${group.short}$%F_GROUP = CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=1, PERSISTENT=PERSISTENT)
#:elif group.dimension == 3
      SURFVARS%GSP_${group.short}$%F_GROUP = CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=MAX(1,YSP_${group.short}$D%NLEVS), NDIM=1, PERSISTENT=PERSISTENT)
#:endif
    ELSE
      SURFVARS%GSP_${group.short}$%F_GROUP = FIELD_${group.dimension+1}$D(DATA=SP_${group.short}$)
    END IF
    END ASSOCIATE

#:endfor

#:for group in surface_diagnostic
    ASSOCIATE(SD_${group.short}$=>YDSURF%SD_${group.short}$, YSD_${group.short}$=>YDSURF%YSD_${group.short}$, YSD_${group.short}$D=>YDSURF%YSD_${group.short}$D)
#:for v in group.variables
#:if v.array == 1
    IF (ASSOCIATED(YSD_${group.short}$%Y${v.name}$)) THEN
      CALL SELF%CREATE_SURFACE_VARIABLE_ARRAY_${group.dimension}$D(NAME='SD_${group.short}$_${v.name}$', &
       & VARIABLES=SURFVARS%GSD_${group.short}$%V${v.name}$, ARRAY=SD_${group.short}$, &
       & META=YSD_${group.short}$%Y${v.name}$(:), DESCR=YSD_${group.short}$D, &
       & ACTIVE=ASSOCIATED(YSD_${group.short}$%Y${v.name}$))
    END IF
#:elif v.array == 2
    IF (ASSOCIATED(YSD_${group.short}$%Y${v.name}$)) THEN
      CALL SELF%CREATE_SURFACE_VARIABLE_ARRAY2_${group.dimension}$D(NAME='SD_${group.short}$_${v.name}$', &
       & VARIABLES=SURFVARS%GSD_${group.short}$%V${v.name}$, ARRAY=SD_${group.short}$, &
       & META=YSD_${group.short}$%Y${v.name}$(:,:), DESCR=YSD_${group.short}$D, &
       & ACTIVE=ASSOCIATED(YSD_${group.short}$%Y${v.name}$))
    END IF
#:else
    CALL SELF%CREATE_SURFACE_VARIABLE_${group.dimension}$D(NAME='SD_${group.short}$_${v.name}$', &
     & VARIABLE=SURFVARS%GSD_${group.short}$%V${v.name}$, ARRAY=SD_${group.short}$, &
     & META=YSD_${group.short}$%Y${v.name}$, DESCR=YSD_${group.short}$D, &
     & ACTIVE=ASSOCIATED(YSD_${group.short}$%Y${v.name}$))
#:endif
#:endfor

    IF (YSD_${group.short}$D%NDIM == 0) THEN
#:if group.dimension == 2
      SURFVARS%GSD_${group.short}$%F_GROUP = CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=1, PERSISTENT=PERSISTENT)
#:elif group.dimension == 3
      SURFVARS%GSD_${group.short}$%F_GROUP = CREATE_TEMPORARY(GEOM=SELF%GEOM, NLEV=MAX(1,YSD_${group.short}$D%NLEVS), NDIM=1, PERSISTENT=PERSISTENT)
#:endif
    ELSE
      SURFVARS%GSD_${group.short}$%F_GROUP = FIELD_${group.dimension+1}$D(DATA=SD_${group.short}$)
    END IF
    END ASSOCIATE
#:endfor

  END SUBROUTINE FIELD_REGISTRY_REGISTER_SURFACE_FIELDS

END MODULE FIELD_REGISTRY_MOD
